<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue学习笔记-day04]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day04%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记-day03]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day03%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记-day02]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day02%2F</url>
    <content type="text"><![CDATA[Vue.js - Day2品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive(&apos;on&apos;).keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, &apos;font-weight&apos;: function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective(&apos;red-color&apos;, &#123; bind: function () &#123; this.el.style.color = &apos;red&apos;; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require(&apos;http&apos;);// 导入解析 URL 地址的核心模块const urlModule = require(&apos;url&apos;);const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on(&apos;request&apos;, (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === &apos;/getjsonp&apos;) &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: &apos;zs&apos;, age: 22, gender: &apos;男&apos;, hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end(&apos;404&apos;); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log(&apos;server running at http://127.0.0.1:3000&apos;);&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get(&apos;http://127.0.0.1:8899/api/getlunbo&apos;).then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = &apos;http://127.0.0.1:8899/api/post&apos;; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: &apos;zs&apos; &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = &apos;http://127.0.0.1:8899/api/jsonp&apos;; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = &apos;translateX(500px)&apos;; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = &apos;translateX(0px)&apos;; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; txt: &apos;&apos;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = &apos;&apos;; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记-day01]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day01%2F</url>
    <content type="text"><![CDATA[Vue.js - Day1课程介绍前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp后5天： 以项目驱动教学； 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloak使用 v-cloak 能够解决 插值表达式闪烁的问题 Vue指令之v-text和v-html 默认 v-text 是没有闪烁问题的v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法v-bind: 是 Vue中，提供的用于绑定属性的指令 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果Vue 中提供了 v-on: 事件绑定机制 跑马灯效果 HTML结构： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; info: &apos;猥琐发育，别浪~！&apos;, intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定注意： v-model 只能运用在 表单元素中，例如： input(radio, text, address, email….) select checkbox textarea 简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; n1: 0, n2: 0, result: 0, opt: &apos;0&apos; &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case &apos;0&apos;: this.result = parseInt(this.n1) + parseInt(this.n2); break; case &apos;1&apos;: this.result = parseInt(this.n1) - parseInt(this.n2); break; case &apos;2&apos;: this.result = parseInt(this.n1) * parseInt(this.n2); break; case &apos;3&apos;: this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for=&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show v-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写搜索二叉树]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%89%8B%E5%86%99%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[package datastruct; /** * 排序二叉树(搜索二叉树) */ public class Tree&lt;E extends Comparable&lt;E&gt;&gt; { //root用来保存根节点的引用 private Node root; //节点的个数 private int size; /** * 描述二叉树当中的一个节点。 */ private class Node { //data用来保存添加的元素，这些元素应该实现Comparable接口，方便比较大小 E data; //left,right用来保存左右子节点的引用 Node left; Node right; public Node(E e) { this.data = e; } /** * 将新节点添加到当前节点下面 * * @param e 要添加的节点 * @return 添加成功，返回true */ public boolean addChild(E e) { /* *新节点的元素值与当前节点的元素值相等，则不用添加 * 注： * 二叉树不允许重复元素 */ if (e.compareTo(this.data) == 0) { return false; } else if (e.compareTo(this.data) &lt; 0) { /* * 新节点的元素值比当前节点的元素值小， * 则新节点应该添加到当前节点的左子树上 */ if (this.left == null) { //左子树为空，则新节点作为当前节点的左子树 this.left = new Node(e); size++; return true; } else { return left.addChild(e); } } else if (e.compareTo(data) &gt; 0) { /* * 新节点的元素值比当前节点的元素值大， * 则新节点应该添加到当前节点的右子树上 */ if (this.right == null) { this.right = new Node(e); size++; return true; } else { return right.addChild(e); } } else { return false; } } /** * 对当前节点进行中序遍历，并且将当前节点元素的值添加到builder对象里面 * * @param builder */ public void appendTo(StringBuilder builder) { //先中序遍历左子树 if (this.left != null) { this.left.appendTo(builder); } //访问根节点 builder.append(this.data + &quot;,&quot;); //中序遍历右子树 if (this.right != null) { this.right.appendTo(builder); } } } /** * 将元素添加到二叉树合适的位置 * * @param e 被添加的元素 * @return 添加成功返回true */ public boolean add(E e) { Node node = new Node(e); if (root == null) { //当前二叉树为空，则该节点为根节点 root = node; root.left = null; root.right = null; //节点个数加1 size++; return true; } else { //当前二叉树不为空,则将该节点作为根节点的子节点进行添加 return root.addChild(e); } } /** * 将二叉树按照中序遍历的方式输出所有节点的元素值 * * @return */ @Override public String toString() { if (root == null) { return &quot;[]&quot;; } StringBuilder builder = new StringBuilder(&quot;[&quot;); root.appendTo(builder); builder.delete(builder.lastIndexOf(&quot;,&quot;), builder.length()); return builder.append(&quot;]&quot;).toString(); } }]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写双向循环列表LinkedList]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%89%8B%E5%86%99%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8LinkedList%2F</url>
    <content type="text"><![CDATA[package cn.tedu.datastruct; public class LinkedList&lt;E&gt; { /* head保存链表头节点的引用 */ private Node head; private int size; /** * Node用来描述一个节点, * 其中E用来存放数据， * prev存放前驱节点的引用， * next存放后继节点的引用 */ private class Node { E data; Node prev; Node next; public Node(E e) { this.data = e; } } /** * 将元素添加到链表的末尾 * * @param e 待添加的元素 * @return 添加成功返回true */ public boolean add(E e) { if (head == null) { //链表为空,则当前新添加的节点为头节点 head = new Node(e); head.prev = head; head.next = head; size++; return true; } /* 如果链表不为空，则先找到尾节点，然后重新建立节点的引用关系 */ //找到尾节点 Node last = head.prev; //重新建立节点的引用关系 Node node = new Node(e); last.next = node; node.next = head; head.prev = node; node.prev = last; size++; return true; } /** * 在指定下标处添加新元素 * * @param index 下标 * @param element 新元素 */ public void add(int index, E element) { //判断下标的取值 if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException(&quot;下标越界&quot;); } //如果添加的下标等于size，即向末尾追加 if (index == size) { add(element); return; } //得到指定下标的源节点 Node node = getByIndex(index); //创建新节点 Node newNode = new Node(element); //得到前一个节点 Node prev = node.prev; //重新建立引用关系 prev.next = newNode; newNode.next = node; node.prev = newNode; newNode.prev = prev; //如果添加的下标是0，则这个新节点为头结点 if (index == 0) { head = newNode; } size++; } /** * 获得链表长度 * @return 链表的长度 */ public int size() { return size; } /** * 返回指定下标的某个元素 * * @param index 下标 * @return 对应下标的某个元素 */ public E get(int index) { if (index &lt; 0 || index &gt;= size) { throw new IndexOutOfBoundsException(&quot;下标越界&quot;); } return getByIndex(index).data; } /** * 删除指定下标的元素 * * @param index 下标 * @return 被删除的元素 */ public E remove(int index) { if (index &lt; 0 || index &gt;= size) { throw new IndexOutOfBoundsException(&quot;下标越界&quot;); } if (size == 1) { //只有一个节点 E data = head.data; head = null; size--; return data; } //获取被删除的节点 Node node = getByIndex(index); //被删除节点的前一个节点 Node prev = node.prev; //被删除节点的下一个节点 Node next = node.next; //重新建立引用关系 prev.next = next; next.prev = prev; //如果删除的是第一个节点，应该让第二个节点充当头节点 if (index == 0) { head = node.next; } //链表的长度减1 size--; //返回被删除的元素 return node.data; } /** * 返回链表中各个元素的值，如果链表为空，返回&quot;[]&quot;，否则，各个元素值使用&quot;,&quot;分隔 * * @return */ @Override public String toString() { if (head == null) { return &quot;[]&quot;; } Node next = head.next; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;[&quot; + head.data); /* 开始进行遍历，直到下一个节点是头节点，则循环结束 */ while (next != head) { stringBuffer.append(&quot;, &quot; + next.data); next = next.next; } stringBuffer.append(&quot;]&quot;); return stringBuffer.toString(); } /** * 返回执行下标的节点 * * @param index 下标 * @return 对应下标的节点 */ private Node getByIndex(int index) { Node node = head; if (index &lt;= size / 2) { for (int i = 0; i &lt; index; i++) { node = node.next; } } else { for (int i = 0; i &lt; size - index; i++) { node = node.prev; } } return node; } }]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot设置上传文件限制]]></title>
    <url>%2F2019%2F09%2F03%2FSpringBoot%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot默认上传文件限制为1MB，如果上传的文件超过1MB项目会报告错误设置上传文件大小的限制方法一：1.低版本：1.xx spring.http.multipart.max-file-size=10MB spring.http.multipart.max-request-size=10MB2.高版本：2.xx spring.servlet.multipart.max-file-size=30Mb spring.servlet.multipart.max-request-size=30Mb方法二： 在启动类中添加@Configuration注解 然后在类中添加如下方法： @Bean public MultipartConfigElement getMultipartConfigElement() { MultipartConfigFactory factory= new MultipartConfigFactory(); //单个文件最大值 factory.setMaxFileSize(DataSize.ofMegabytes(100)); //总的文件最大值 factory.setMaxRequestSize(DataSize.ofMegabytes(100)); MultipartConfigElement element = factory.createMultipartConfig(); return element; }]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea中无法使用el表达式的解决方法]]></title>
    <url>%2F2019%2F09%2F03%2FIdea%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[修改web.xml文件的web-app节点如下： &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;/web-app&gt;]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见面试题]]></title>
    <url>%2F2019%2F09%2F03%2FJava%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Get和Post请求的区别GET请求会把请求参数体现在URL中，通常，不推荐用于敏感信息的传递，另外，传递的数据也会受到URL长度的限制，通常建议值是不超过2K，具体值取决于浏览器和服务器的设置值，向下兼容(取较小的值)； POST请求会把请求参数封装在请求体中，并不体现在URL中，对外不可见，所以，可以用于传递敏感信息，并且，不受到长度限制！ 尽管POST请求有一定的优势，但是，也存在一些使用的不便利，例如：不适用于需要刷新的应用场景，因为刷新会反复提交数据；另外，不适合分享URL。 另外，GET请求的速度比POST请求更快！ 转发和重定向的区别转发是1次请求，当请求到服务器的控制器后，控制器可以将请求转发给JSP页面进行处理，整个转发过程是服务器内部行为，对于客户端来说是不可见的，所以，在转发时，客户端的浏览器中的URL并不会发生变化！ 重定向是2次请求，当请求到器控制器后，控制器会要求客户端进行重定向，会响应302响应码，并给客户端目标地址，然后客户端会根据目标地址发出第2次请求，所以，在重定向时，客户端的浏览器中的URL会是第2次请求的URL！ 由于转发是发生在服务器内部的行为，所以，控制器可以将数据转发给JSP页面！而重定向是2次请求，由于HTTP协议是无状态协议，所以，第1次请求处理的数据不可以直接(可以通过其它技术手段)用于第2次请求时的处理过程！ Cookie和Session的区别Cookie和Session都用与解决无连接协议的状态保持问题。Cookie是服务器下发给游览器，保存到游览器端，Cookie是不安全的，会被篡改和禁用，且只能保存字符串且最多保存4K。Session分为SessionID和Session对象，SessionID是依赖Cookie保存在游览器端的，Session对象保存在服务器端，相比较Cookie，Session保存数据更安全，可以保存任意类型的数据。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar包和war包的介绍和区别]]></title>
    <url>%2F2019%2F09%2F03%2Fjar%E5%8C%85%E5%92%8Cwar%E5%8C%85%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[详见：https://www.jianshu.com/p/3b5c45e8e5bd]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还原表单控件的默认状态]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%BF%98%E5%8E%9F%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[$(“#form-addnew”)[0].reset();//js中的函数]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA常用快捷键]]></title>
    <url>%2F2019%2F09%2F03%2FIDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[详见：https://www.jianshu.com/p/1ca2ff26d064]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.ajajx()的使用]]></title>
    <url>%2F2019%2F09%2F03%2Fajajx-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[详见：https://www.w3school.com.cn/jquery/ajax_ajax.asp]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.cookie()的使用]]></title>
    <url>%2F2019%2F09%2F03%2Fcookie-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在jQuery官网下载jQuery.cookie.js文件 https://plugins.jquery.com/cookie/ 在页面中导入 &lt;scriptsrc=”../bootstrap3/js/jquery.cookie.js”type=”text/javascript” 使用 (1)创建一个整站cookie,当没有指明 cookie有效时间时，所创建的cookie有效期默认到用户关闭浏览器为止 ①$.cookie(‘name’, ‘value’); (2)创建一个整站cookie ，cookie 的有效期为 7 天 ①$.cookie(‘name’, ‘value’, { expires: 7 }); (3)创建一个仅对 path 路径页面有效的 cookie ，cookie 的有效期为 7 天 ①$.cookie(‘name’, ‘value’, { expires: 7, path: ‘/‘ }); (4)读取 cookie ①$.cookie(‘name’); // 如果cookie存在 则获取到cookie值 =&gt; ‘value’ ②$.cookie(‘nothing’); // 如果cookie不存在 则返回 =&gt; undefined (5)获取所有可见的 cookie ①$.cookie(); // 数据格式 =&gt; { name: ‘value’ } (6)删除 cookie ①$.removeCookie(‘name’); // =&gt; true ②$.removeCookie(‘nothing’); // =&gt; false (7)删除带属性的cookie ①$.cookie(‘name’, ‘value’, { path: ‘/‘ });// 错误 ②$.removeCookie(‘name’); // =&gt; false// 正确 ③$.removeCookie(‘name’, { path: ‘/‘ }); // =&gt; true 属性 (1)domain–创建cookie所在网页所拥有的域名 ①$.cookie(‘name’, ‘value’, { domain: ‘weber.pub’ }); (2)secure–默认是false，如果为true，cookie的传输协议需为https； ①$.cookie(‘name’, ‘value’, { secure: true }); (3)raw–默认为false，读取和写入时候自动进行编码和解码（使用encodeURIComponent编码，使用decodeURIComponent解码），关闭这个功能，请设置为true。 ①$.cookie.raw = true; (4)json ①$.cookie.json = true;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea下使用struts2]]></title>
    <url>%2F2019%2F09%2F03%2Fidea%E4%B8%8B%E4%BD%BF%E7%94%A8struts2%2F</url>
    <content type="text"><![CDATA[详见:https://blog.csdn.net/weixin_41060905/article/details/82890332]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM详解]]></title>
    <url>%2F2019%2F08%2F11%2FBOM%E5%92%8CDOM%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载自：https://www.cnblogs.com/wangxiang9528/p/9855358.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript this 关键字]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript-this-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[JavaScript this 关键字面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 方法中的this在对象方法中， this 指向调用它所在方法的对象。 在上面一个实例中，this 表示 person 对象。 fullName 方法所属的对象就是 person。 &lt;script&gt; // 创建一个对象 var person = { firstName: &quot;John&quot;, lastName : &quot;Doe&quot;, id : 5566, fullName : function() { return this.firstName + &quot; &quot; + this.lastName; } }; // 显示对象的数据 document.getElementById(&quot;demo&quot;).innerHTML = person.fullName(); &lt;/script&gt;单独使用this单独使用 this，则它指向全局(Global)对象。 在浏览器中，window 就是该全局对象为 [object Window]: &lt;script&gt; var x = this; document.getElementById(&quot;demo&quot;).innerHTML = x; &lt;/script&gt;函数中使用 this（默认）在函数中，函数的所属者默认绑定到 this 上。 在浏览器中，window 就是该全局对象为 [object Window]: &lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = myFunction(); function myFunction() { return this; } &lt;/script&gt;事件中的 this在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素： &lt;button onclick=&quot;this.style.display=&apos;none&apos;&quot;&gt;点我后我就消失了&lt;/button&gt;总结 在对象方法中， this 指向调用它所在方法的对象。 单独使用 this，它指向全局(Global)对象。 函数使用中，this 指向函数的所属者。 在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。 更加详细教程请参见菜鸟教程中的介绍]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax介绍]]></title>
    <url>%2F2019%2F08%2F08%2Fajax%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[AjaxAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 同步和异步传统的WEB应用中，在客户端发出请求与服务器做出响应之间的一段时间里，客户端是不可以做其他操作的，带来的问题就是用户体验差，而服务器响应的结果通常是返回一个页面或者重定向到其他页面。这就是同步。异步请求是，用户可以在不刷新页面的前提下更新页面部分数据（局部更新），在客户端向服务器发生请求后，在等待服务器的响应的这段时间中，用户可以继续进行他的操作，使用这种异步请求可以及时的更新页面的数据，用户体验较好。 XMLHttpRequest对象XMLHttpRequest 对象用于在后台与服务器交换数据。通过这个对象可以实现异步操作。 获取XMLHttpRequest对象var request = new XMLHttpRequest();这种方式不兼容IE5和IE6 XMLHttpRequest发送请求open(method,url,async)//创建请求method-请求方式（字符串类型），url-请求路径（字符串类型），async-同步/异步（boolean类型，true异步，false同步，默认true） send(string)//发送请求string-要发送的数据，字符串类型，get请求可以不填写改参数，因为参数都放在url中，可以传递null值，post请求必须填写 request.setContentHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);设置http的Content-Type头信息，这是告诉游览器我发送的是一个表单，这个方法应该写在open和send之间，否则会抛出异常 XMLHttpRequest获取响应request.responseText获取字符串形式的响应数据 request.responseXML 获取XML形式的响应数据 request.status获取数字状态信息 request.statusText获取文本形式的状态信息 request.getAllResponseHeader()获取所有的响应消息头 request.getResponseHeader(xx)获取指定的消息头的值 request.readState代表服务器响应的变化0-请求未初始化，未调用open1-服务器已经建立，open已经调用了2-请求已接收，接收到头信息了3-请求处理中，接收到响应主体了4-请求已完成，且响应已就绪，也就是响应完成了 Json格式服务器可以向客户端返回一串特定格式的字符串，客户端收到之后进行解析，可以得到自己想要的数据格式： {&quot;属性名&quot;:&quot;值&quot;,&quot;属性名&quot;:&quot;值&quot;,&quot;属性名&quot;:&quot;值&quot;}值的类型可以数字、字符串、数组、对象、null javaScript提供了解析json格式字符串的方法，转化成json对象， 提供的方法有：eval和JSON.parse() eval解析json会把json中的代码执行，而且相对麻烦不建议使用这种方式解析 var jsondata = &apos;{&quot;staff&quot;:[{&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:&quot;70&quot;},{&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:&quot;35&quot;},{&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:&quot;30&quot;}]}&apos;; var jsonobj = eval(&apos;(&apos;+jsondata+&apos;)&apos;);JSON.parse()不会执行json中的代码 var jsondata = &apos;{&quot;staff&quot;:[{&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:&quot;70&quot;},{&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:&quot;35&quot;},{&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:&quot;30&quot;}]}&apos;; var jsonobj = JSON.parse(jsondata);jQuery中的Ajax$.ajax({ &quot;url&quot;:&quot;/login&quot;, &quot;data&quot;:&quot;username=tom&amp;password=1234&quot;, &quot;type&quot;:&quot;post&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json){ }, &quot;error&quot;:function(xhr){ } });函数的参数是一个json对象 url：请求路径 data：请求数据 type：请求方式 dataType：服务器返回的数据类型，一般采用json，可以设置为json success：是一个方法，请求成功后的回调函数，传入返回后的数据， error：是一个方法，请求失败后的回调函数，传入XMLHttpRequest对象]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet——状态管理Session]]></title>
    <url>%2F2019%2F07%2F18%2FServlet%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86Session%2F</url>
    <content type="text"><![CDATA[1.Session(会话)(1)session是什么?服务器端为了保存状态而创建的一个特殊的对象。 注： 当浏览器访问服务器时，服务器端创建一个特殊的 对象(该对象一般称之为session对象，该对象有一个 唯一的id,一般称之为sessionId)。服务器会将sessionId以cookie的方式发送给浏览器。 当浏览器再次访问服务器时，会将sessionId发送 过来，服务器端可以依据sessionId找到对应的session 对象。(2)如何获得session对象?1)方式一:HttpSession s = request.getSession(boolean flag); 注: a.HttpSession是一个接口。 b.如果flag为true: 先查看请求当中是否有sessionId,如果没有， 则创建一个session对象；如果有sessionId, 则依据sessionId查找对应的session对象，如果找 到了，则返回该对象，找不到，则创建一个新的 session对象。 c.如果flag为false: 先查看请求当中是否有sessionId,如果没有， 返回null;如果有sessionId,则依据sessionId查找对应的session对象，如果找到了，则返回该对象，找不到，返回null。 方式二:HttpSession s = request.getSession(); 等价于 request.getSession(true);(3)常用方法1)session.setAttribute(String name,Object obj); 注: 以name作为key,以obj作为value,将数据存放到了 一个Map对象里面。2)Object session.getAttribute(String name); 注: 如果绑订值不存在，返回null。3)session.removeAttribute(String name); 注： 解除绑订。 (4)session超时a.什么是session超时? 服务器会将空闲时间过长的session对象删除掉。 注： 缺省的超时时间长度一般是30分钟。b.如何修改超时时间长度? 方式一 修改web.xml配置文件。 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 方式二 session.setMaxInactiveInterval(int seconds) 注： 设置两次请求之间的最大间隔时间，如果超过了 该时间，则session对象会被删除。(5)删除sessionsession.invalidate() 2. 登录3. session验证step1.登录成功之后，在session对象上绑订一些数据，比如: session.setAttribute(&quot;user&quot;,user);step2.当用户访问需要受保护的资源时(即只有登录成功之后才能访问的资源，比如success.jsp),进行session验证，比如: Object obj = session.getAttribute(&quot;user&quot;); if(obj == null){ //没有登录，重定向到登录页面 response.sendRedirect(&quot;login.jsp&quot;); return; } 练习显示用户上一次访问的时间，如果是第一次访问，则输出“你是第一次访问”。]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet——状态管理Cookie]]></title>
    <url>%2F2019%2F07%2F18%2FSe%E7%8A%B6Servlet%E2%80%94%E2%80%94%E6%80%81%E7%AE%A1%E7%AE%A1%E7%90%86Cookie%2F</url>
    <content type="text"><![CDATA[1. 状态管理(1)什么是状态管理?将浏览器与web服务器之间多次交互当做一个整体来处理，并且将多次交互所产生的数据(即状态)保存下来。 (2)如何进行状态管理?a.方式一 将状态保存在浏览器端 通常使用Cookie技术。b.方式二 将状态保存在服务器端 通常使用Session技术。(3)Cookie1)什么是Cookie?服务器临时存放在浏览器端的少量数据，用于跟踪用户的状态。 当浏览器访问服务器时，服务器会将少量数据以 set-cookie消息头的方式发送给浏览器，浏览器 会将这些数据保存下来。 当浏览器再次访问服务器时，会将这些数据以cookie 消息头的方式发送给服务器。 2)如何添加Cookie?Cookie c = new Cookie(String name,String value); 注: name一般称之为cookie名，value称之为cookie值，都必须是字符串。 response.addCookie(c);3)如何读取Cookie?Cookie[] request.getCookies(); 注： 该方法有可能返回null。 String cookie.getName(); String cookie.getValue();4)cookie的生存时间a.默认情况下，浏览器会将cookie保存在内存里面，浏览器只要关闭，cookie会被删除。 b.可以调用setMaxAge方法来设置cookie的生存时间 cookie.setMaxAge(int seconds); 注: a.单位是秒。 b.当seconds &gt; 0,浏览器会将cookie保存在硬盘上，当超过指定的时间，浏览器会将cookie删除。 c.当seconds &lt; 0,缺省值(浏览器会将cookie保存在内存里面)。 d.当seconds = 0,删除cookie。 比如，要删除一个名称为&quot;username&quot;的cookie,代码如下： Cookie c = new Cookie(&quot;username&quot;,&quot;&quot;); c.setMaxAge(0); response.addCookie(c);5)cookie的编码问题a.什么是cookie的编码问题? cookie只能存放合法的ascii字符，如果要存放中文， 需要将中文转换成合法的ascii字符的形式。b.如何处理? String URLEncoder.encode(String str,String charset); String URLDecoder.decode(String str,String charset); 建议，在实际开发时，对添加的数据统一使用encode 方法来编码。6)cookie的路径问题a.什么是cookie的路径问题? 浏览器访问服务器时，会比较请求地址是否与cookie 的路径匹配，只有匹配的cookie才会被发送。b.cookie的默认路径 cookie的默认路径等于添加该cookie的web组件的路径，比如AddCookieServlet(/day06/addCookie） 添加了一个cookie，则该cookie的默认路径是 &quot;/day06&quot;。c.匹配规则 请求地址要么是等于cookie的路径，要么是cookie的 子路径，只有符合该条件的cookie，浏览器才会发送出去。 d.修改路径 cookie.setPath(String path); 注: path就是路径。7)cookie的限制a. cookie可以被用户禁止。b. cookie不安全。 对于敏感数据，一定要加密。c. cookie只能保存少量的数据。 大约4k左右d. cookie的数量也有限制。 大约是几百个e. cookie只能保存字符串。 练习 写一个Servlet，该Servlet先查看有没有一个名称为“cart”的cookie，如果有，则显示该Cookie的值；如果没有，则添加之。 练习]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet——转发、相对路径与绝对路径]]></title>
    <url>%2F2019%2F07%2F18%2FServlet%E2%80%94%E2%80%94%E8%BD%AC%E5%8F%91%E3%80%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.转发(1)什么是转发?一个web组件将未完成的处理交给另外一个web组件继续做。 注: web组件: jsp或者servlet的统称。 通常是一个servlet获得数据，然后转发给一个jsp 来展现。 (2)如何转发?step1.绑订数据到request对象上。 request.setAttribute(String name,Object obj); 注： a. name通常称之为绑订名，obj称之为绑订值。 b. 该方法内部的实现：就是以name作为key,以 obj作为value,调用Map.put方法。 c. Object request.getAttribute(String name);step2.获得转发器。 RequestDispatcher rd = request.getRequestDispatcher(Sting uri); 注: a.uri:转发的目的地，通常是一个jsp。 b.RequestDispatcher是一个接口，该方法会返回 一个符合该接口的对象，这个对象一般我们称 之为转发器。 c.转发的本质是一个web组件通知容器去调用另外一个web组件，可以将转发器理解为web组件通知容器的媒介。step3.转发 rd.forward(request,response);(3)特点a.转发之后，浏览器地址栏的地址不变。 b.转发的目的地有限制，要求属于同一个web应用。 2.比较转发与重定向(1)地址栏地址有无变化转发之后，浏览器地址栏地址不变；重定向之后，浏览器地址栏地址会发生改变。 (2)目的地有无限制转发有限制，重定向没有任何限制。 (3)能否共享request对象和response对象。转发可以，重定向不行。 注: 容器收到请求之后，会立即创建request对象和 response对象。当响应发送完毕，容器会立即销毁 这两个对象。也就是说，request对象和response 对象的生存时间是一次请求与响应期间存在。 重定向是两次请求。(4)一件事是否完成转发是一件事未做完，让另外一个web组件继续做;而重定向是一件事已经完成，再做另外一件独立的事件。 2.路径问题链接、表单提交、重定向和转发如何填写相应的路径 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;form action=&quot;&quot;&gt; response.sendRedirect(&quot;&quot;) request.getRequestDispatcher(&quot;&quot;)(1)什么是相对路径?不以”/“开头的路径 (2)什么是绝对路径?以”/“开头的路径 (3)如何写绝对路径?链接、表单提交、重定向从应用名开始写；转发从应用名之后开始写。 注: 不要将应用名直接写在路径里面！ 应该使用以下方法来获得实际部署时的应用名: String request.getContextPath(); 在实际开发时，建议尽量使用绝对路径。# 练习 添加用户时，如果用户名已经存在，则在添加用户的页面上提示“用户名已经存在”。否则，将用户信息插入到数据库，然后重定向到用户列表。 提示:step1.在UserDAO类中添加一个方法 public User findByUsername(String uname);step2.修改AddUserServlet 调用UserDAO的findByUsername方法，如果返回 值不为null,则绑订错误提示信息到request，然后 转发到addUser.jsp;否则调用UserDAO的save方法， 将用户信息插入到数据库。step3.修改addUser.jsp (显示提示信息)]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学子商城———项目分析、用户注册]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%AD%A6%E5%AD%90%E5%95%86%E5%9F%8E%E2%80%94%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E3%80%81%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[1. 项目大致分析需要处理的数据的种类：用户，商品，收货地址，购物车，订单，收藏，商品分类…… 开发时，应该先完成：比较简单的、与其它数据关联不大、是其它数据的基础支撑的数据，例如用户数据。 所以，处理数据的顺序可以大致是：用户 &gt; 收货地址 &gt; 商品分类与商品 &gt; 购物车与收藏 &gt; 订单。 每种数据的处理，都涉及一些功能，以用户数据为例，可能有：注册、登录、修改资料、修改密码、上传头像，通常，遵循“增 &gt; 查 &gt; 删 &gt; 改”且“由简到难”的步骤一一完成，所以，当处理用户数据时，应该：注册 &gt; 登录 &gt; 修改密码 &gt; 修改资料 &gt; 上传头像。 在处理每一个功能时，都应该遵循的开发顺序：持久层 &gt; 业务层 &gt; 控制器层 &gt; 界面。 2. 用户-注册-持久层创建数据库 在MySQL中创建名为tedu_store的数据库： CREATE DATABASE tedu_store;创建数据表 CREATE TABLE t_user ( id INT AUTO_INCREMENT COMMENT &apos;id&apos;, username VARCHAR(20) UNIQUE NOT NULL COMMENT &apos;用户名&apos;, password CHAR(32) NOT NULL COMMENT &apos;密码&apos;, salt CHAR(36) NOT NULL COMMENT &apos;盐值&apos;, gender INT COMMENT &apos;性别&apos;, phone VARCHAR(20) COMMENT &apos;手机号码&apos;, email VARCHAR(50) COMMENT &apos;电子邮箱&apos;, avatar VARCHAR(100) COMMENT &apos;头像&apos;, is_delete INT DEFAULT 0 COMMENT &apos;是否删除，0-未删除，1-已删除&apos;, created_user VARCHAR(20) COMMENT &apos;创建者&apos;, created_time DATETIME COMMENT &apos;创建时间&apos;, modified_user VARCHAR(20) COMMENT &apos;最后修改者&apos;, modified_time DATETIME COMMENT &apos;最后修改时间&apos;, PRIMARY KEY(id) ) DEFAULT CHARSET=UTF8;创建项目 打开Spring Boot的官方网站：https://start.spring.io/ 输入各参数，并勾选MyBatis和MySQL，生成项目。 将下载的压缩包解压到Workspace中，然后，在Eclipse中通过Import &gt; Import &gt; Existing Maven Projects导入该项目（如果是第1次使用Spring Boot，需要保证与Maven服务器的网络畅通）。 由于创建项目时勾选了数据库编程的依赖，所以，当Spring Boot启动时，会尝试创建数据源对象，但是，没有添加任何配置时，是无法创建数据源对象的，就会导致启动失败，所以，先在配置文件application.properties中添加数据源的配置： # spring datasource spring.datasource.url=jdbc:mysql://localhost:3306/tedu_store?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root 框架会自动读取数据库驱动jar包中的META-INF/services/java.sql.Driver文件，文件中的值就是数据源的driverClassName的值，所以，配置数据源时，无须配置driverClassName。 完成后，测试连接是否可用： package cn.tedu.store.db; import java.sql.SQLException; import javax.sql.DataSource; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class DataSourceTestCase { @Autowired DataSource dataSource; @Test public void getConnection() throws SQLException { System.out.println(dataSource.getConnection()); } }创建实体类 创建实体类的基类cn.tedu.store.entity.BaseEntity，添加日志相关的4个属性，并实现序列化接口： package cn.tedu.store.entity; import java.io.Serializable; import java.util.Date; public class BaseEntity implements Serializable { private static final long serialVersionUID = -6185124879935579311L; private String createdUser; private Date createdTime; private String modifiedUser; private Date modifiedTime; public String getCreatedUser() { return createdUser; } public void setCreatedUser(String createdUser) { this.createdUser = createdUser; } public Date getCreatedTime() { return createdTime; } public void setCreatedTime(Date createdTime) { this.createdTime = createdTime; } public String getModifiedUser() { return modifiedUser; } public void setModifiedUser(String modifiedUser) { this.modifiedUser = modifiedUser; } public Date getModifiedTime() { return modifiedTime; } public void setModifiedTime(Date modifiedTime) { this.modifiedTime = modifiedTime; } }创建cn.tedu.store.entity.User类，添加与数据表对应的属性，并继承自以上的BaseEntity类： package cn.tedu.store.entity; public class User extends BaseEntity { private static final long serialVersionUID = -3643571432521920213L; private Integer id; private String username; private String password; private String salt; private Integer gender; private String phone; private String email; private String avatar; private Integer isDelete; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getSalt() { return salt; } public void setSalt(String salt) { this.salt = salt; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAvatar() { return avatar; } public void setAvatar(String avatar) { this.avatar = avatar; } public Integer getIsDelete() { return isDelete; } public void setIsDelete(Integer isDelete) { this.isDelete = isDelete; } @Override public String toString() { return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;, salt=&quot; + salt + &quot;, gender=&quot; + gender + &quot;, phone=&quot; + phone + &quot;, email=&quot; + email + &quot;, avatar=&quot; + avatar + &quot;, isDelete=&quot; + isDelete + &quot;]&quot;; } }持久层接口 创建cn.tedu.store.mapper.UserMapper接口，并在接口中添加抽象方法： package cn.tedu.store.mapper; import cn.tedu.store.entity.User; /** * 处理用户数据的持久层 */ public interface UserMapper { /** * 插入用户数据 * @param user 用户数据 * @return 受影响的行数 */ Integer addnew(User user); /** * 根据用户名查询用户数据 * @param username 用户名 * @return 匹配的用户数据，如果没有匹配的数据，则返回null */ User findByUsername(String username); } 由于注册时需要判断用户名是否被占用，所以，添加了根据用户名查询用户数据的方法。 为了使得MyBatis能找到接口，可以在启动类之前添加@MapperScan注解： @SpringBootApplication @MapperScan(&quot;cn.tedu.store.mapper&quot;) public class TeduStoreApplication { public static void main(String[] args) { SpringApplication.run(TeduStoreApplication.class, args); } }当然，在接口文件之前添加@Mapper注解也可以，相比之下，使用@MapperScan是一次性配置，如果不使用它的话，每个接口文件之前都必须添加@Mapper注解，这2种方案选取其中的任何一种即可。 接下来，需要配置接口文件的映射，首先，在application.properties中添加XML文件位置的配置： # mybatis mybatis.mapper-locations=classpath:mappers/*.xml则需要在resources下创建名为mappers的文件夹，然后，在该文件夹下添加映射的XML，配置以上抽象方法的映射： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.tedu.store.mapper.UserMapper&quot;&gt; &lt;!-- 插入用户数据 --&gt; &lt;!-- Integer addnew(User user) --&gt; &lt;insert id=&quot;addnew&quot; parameterType=&quot;cn.tedu.store.entity.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO t_user ( username, password, salt, gender, phone, email, avatar, is_delete, created_user, created_time, modified_user, modified_time ) VALUES ( #{username}, #{password}, #{salt}, #{gender}, #{phone}, #{email}, #{avatar}, #{isDelete}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime} ) &lt;/insert&gt; &lt;!-- 根据用户名查询用户数据 --&gt; &lt;!-- 应用于：注册，登录 --&gt; &lt;!-- User findByUsername(String username) --&gt; &lt;select id=&quot;findByUsername&quot; resultType=&quot;cn.tedu.store.entity.User&quot;&gt; SELECT id, username, password, salt, avatar, is_delete isDelete FROM t_user WHERE username=#{username} &lt;/select&gt; &lt;/mapper&gt;当以上内容全部完成后，应该执行单元测试： package cn.tedu.store.mapper; import java.util.Date; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import cn.tedu.store.entity.User; @RunWith(SpringRunner.class) @SpringBootTest public class UserMapperTestCase { @Autowired private UserMapper userMapper; @Test public void addnew() { Date now = new Date(); User user = new User(); user.setUsername(&quot;root&quot;); user.setPassword(&quot;1234&quot;); user.setGender(1); user.setPhone(&quot;13800138001&quot;); user.setEmail(&quot;root@tedu.cn&quot;); user.setSalt(&quot;Hello,MD5!&quot;); user.setIsDelete(0); user.setCreatedUser(&quot;Admin&quot;); user.setModifiedUser(&quot;Admin&quot;); user.setCreatedTime(now); user.setModifiedTime(now); Integer rows = userMapper.addnew(user); System.err.println(&quot;rows=&quot; + rows); } @Test public void findByUsername() { String username = &quot;root&quot;; User user = userMapper.findByUsername(username); System.err.println(user); } }3. 用户-注册-业务层业务层应该有业务层接口与实现类，允许被外部（控制器或其它业务类）调用的方法应该在接口中声明，例如reg()、login()方法等。 当前完成的是“注册”功能，则先创建业务层接口cn.tedu.store.service.IUserService： /** * 处理用户数据的业务层接口 */ public interface IUserService { }已知注册过程中，可能出现“用户名被占用异常”、“插入数据异常”，这2种都是业务异常，则应该在cn.tedu.store.service.exception先创建对应的异常类： ServiceException DuplicateKeyException InsertException然后，在接口中声明“注册”的抽象方法： /** * 用户注册 * @param user 用户的注册信息 * @return 成功注册的用户数据 * @throws DuplicateKeyException * @throws InsertException */ User reg(User user) throws DuplicateKeyException, InsertException; 如果事先并不清楚可能抛出哪些异常，甚至还没有创建对应的异常类，可以直接编写业务方法的代码，后续再补充抛出异常的声明。 然后，创建cn.tedu.store.service.impl.UserServiceImpl类，并实现IUserService接口： package cn.tedu.store.service.impl; import cn.tedu.store.entity.User; import cn.tedu.store.service.IUserService; import cn.tedu.store.service.exception.DuplicateKeyException; import cn.tedu.store.service.exception.InsertException; public class UserServiceImpl implements IUserService { @Override public User reg(User user) throws DuplicateKeyException, InsertException { // TODO Auto-generated method stub return null; } }关于业务层的实现类，创建后，固定的任务有： 添加@Service注解； 声明@Autowired private UserMapper userMapper;持久层对象； 然后，添加与持久层对应的方法（甚至方法的声明几乎相同，如果是增删改方法，在业务层中，返回值可以调整为void，并通过异常表示操作失败），并声明为私有，通过调用持久层对象来完成方法： /** * 插入用户数据 * @param user 用户数据 * @return 受影响的行数 * @throws InsertException */ private void addnew(User user) { Integer rows = userMapper.addnew(user); if (rows != 1) { throw new InsertException( &quot;增加用户数据时出现未知错误！&quot;); } } /** * 根据用户名查询用户数据 * @param username 用户名 * @return 匹配的用户数据，如果没有匹配的数据，则返回null */ private User findByUsername(String username) { return userMapper.findByUsername(username); }然后，在公有的reg()方法中编写思路： @Override public User reg(User user) throws DuplicateKeyException, InsertException { // 根据尝试注册的用户名查询用户数据 // 判断查询到的数据是否为null // 是：用户名不存在，允许注册，则执行注册 // -- 返回注册的用户对象 // 否：用户名已被占用，抛出DuplicateKeyException异常 return null; }然后，完成代码的编写： @Override public User reg(User user) throws DuplicateKeyException, InsertException { // 根据尝试注册的用户名查询用户数据 User data = findByUsername( user.getUsername()); // 判断查询到的数据是否为null if (data == null) { // 是：用户名不存在，允许注册，则执行注册 addnew(user); // 返回注册的用户对象 return user; } else { // 否：用户名已被占用，抛出DuplicateKeyException异常 throw new DuplicateKeyException( &quot;注册失败！尝试注册的用户名(&quot; + user.getUsername() + &quot;)已经被占用！&quot;); } }虽然还有“加密”及其它细节没有处理，但是，可以先进行测试，所以，创建cn.tedu.store.service.UserServiceTestCase： package cn.tedu.store.service; import java.util.Date; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import cn.tedu.store.entity.User; import cn.tedu.store.service.exception.ServiceException; @RunWith(SpringRunner.class) @SpringBootTest public class UserServiceTestCase { @Autowired private IUserService userService; @Test public void reg() { try { Date now = new Date(); User user = new User(); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;1234&quot;); user.setGender(1); user.setPhone(&quot;13800138002&quot;); user.setEmail(&quot;admin@tedu.cn&quot;); user.setSalt(&quot;Hello,MD5!&quot;); user.setIsDelete(0); user.setCreatedUser(&quot;Admin&quot;); user.setModifiedUser(&quot;Admin&quot;); user.setCreatedTime(now); user.setModifiedTime(now); User result = userService.reg(user); System.err.println(&quot;result=&quot; + result); } catch (ServiceException e) { System.err.println(&quot;错误类型：&quot; + e.getClass().getName()); System.err.println(&quot;错误描述：&quot; + e.getMessage()); } } }接下来，需要完成密码加密的功能，本次加密使用了随机的盐，可以使用UUID作为随机盐。 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。 在Java中，通过java.util.UUID类即可轻松获取到随机的UUID值： String uuid = UUID.randomUUID().toString();在UserServiceImpl中添加加密方法： /** * 获取根据MD5加密的密码 * @param srcPassword 原密码 * @param salt 盐值 * @return 加密后的密码 */ private String getMd5Password( String srcPassword, String salt) { // 【注意】以下加密规则是自由设计的 // ---------------------------- // 盐值 拼接 原密码 拼接 盐值 String str = salt + srcPassword + salt; // 循环执行10次摘要运算 for (int i = 0; i &lt; 10; i++) { str = DigestUtils .md5DigestAsHex(str.getBytes()); } // 返回摘要结果 return str; }然后，在reg()方法中，在执行注册之前，先获取随机盐值，获取原始密码，执行加密，然后把盐值、加密后的密码封装回User对象中，再执行注册： // 是：用户名不存在，允许注册，则处理密码加密 // 加密-1：获取随机的UUID作为盐值 String salt = UUID.randomUUID().toString(); // 加密-2：获取用户提交的原始密码 String srcPassword = user.getPassword(); // 加密-3：基于原始密码和盐值执行加密，获取通过MD5加密的密码 String md5Password = getMd5Password(srcPassword, salt); // 加密-4：将加密后的密码封装在user对象中 user.setPassword(md5Password); // 加密-5：将盐值封装在user对象中 user.setSalt(salt); // 执行注册 addnew(user);然后，在执行注册之前，还应该补充非用户提交的数据： // 是否已经删除：否 user.setIsDelete(0); // 4项日志 Date now = new Date(); user.setCreatedUser(user.getUsername()); user.setCreatedTime(now); user.setModifiedUser(user.getUsername()); user.setModifiedTime(now);至此，用户注册功能已经完成，由于前序产生的数据可能存在密码没有加密等问题，后续将无法正常使用，所以，应该清除t_user表中所有数据，后续需要数据时，重新注册即可。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot概念及应用、整合MyBatis、分层开发实战]]></title>
    <url>%2F2019%2F06%2F28%2FSpringBoot%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%E3%80%81%E6%95%B4%E5%90%88MyBatis%E3%80%81%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[SpringBoot1. 基本概念每次创建新的SSM项目，都需要：创建Maven项目，添加依赖，配置web.xml，添加spring的配置文件，进行springmvc的相关配置，添加数据库的配置文件，配置mybatis等……准备工作相当的多，而且，随着项目的深入，可能还需要在开发过程中添加新的依赖或新的配置。 事实上，每个不同的项目，经历以上的过程是极为相似的！ 使用SpringBoot可以快速的创建项目，却不用关心以上各种配置，在SpringBoot中，有一项开发理念就是“约定大于配置”，即：大多数人共同遵守的配置习惯，将在SpringBoot中成为默认配置，开发者就不必再关心这些配置了！ 当然，SpringBoot还有更多特性，后续再补充！ 2. 基本使用访问 默认的界面： 点击绿色按钮偏上方的 Switch to the full version. 链接可以展开完整界面，例如： 然后，确定当前需要创建的项目的参数，主要是： 顶部的项目类型、开发语言、SpringBoot版本； Group，例如填写为com.springboot； Artifact，例如填写为sample； Name，表示项目名称，自动为Artifact的值，可以不更改； Description：项目描述； Package Name：项目的根包，在SpringBoot中，任何自定义组件都必须在根包或其子包中，例如控制器类、业务类等； Packaging：WEB应用必须选择war； Java Version：默认为8，也可以使用较低版本。 至此，项目的配置就已经完成，点击绿色的 Generate Project 按钮即可下载项目，得到项目的压缩包，将其解压，并剪切到Workspace中（这一步并不是必须的），然后在Eclipse中选择Import &gt; Existing Maven Projects导入该项目，保证当前计算机是可以连接到Maven服务器，然后，项目会自动更新，添加所需要的所有依赖，至此，项目创建完成！ 3. Hello, SpringBoot设计目标：当输入某请求时，服务器返回&quot;Hello, SpringBoot!&quot;。 在项目的根包下创建子包controller，然后创建控制器类，例如HelloController，然后，添加@RestController注解： @RestController public class HelloController { } @RestController也是一种@Controller，并且，表示该控制器类中所有处理请求的方法都是@ResponseBody的。使用这个注解后，处理请求也就不可以是转发或重定向了，如果一定要转发或重定向，必须使用原有@Controller注解，并且处理请求的方法上不可以添加@ResponseBody。 然后，添加处理请求的方法： @RestController public class HelloController { @GetMapping(&quot;/hello.do&quot;) public String sayHello() { return &quot;Hello, SpringBoot!&quot;; } }至此，简单的HelloWorld就已经完成！ 项目的根包下有SampleApplication类（类名中Application左侧的是项目的Artifact名，所以，不同的项目，该类的名称可能不同），该类是SpringBoot项目的启动类，直接以Run as &gt; Java Application方式启动即可，启动时，控制台会有启动日志： 其中，有一条： Tomcat started on port(s): 8080 (http) with context path &apos;&apos;SpringBoot是内置Tomcat的，所以，项目本身也不需要添加Tomcat运行环境，并且，SpringBoot部署项目时，如以上日志描述的，使用的Context Path是空值，以前访问时的URL可能是： http://localhost:8080/项目名/hello.do而在SpringBoot项目中则是： http://localhost:8080/hello.do也就是不需要再在URL中添加项目名了，执行效果例如： 4. 关于静态资源项目中的src\main\resources\下的static文件夹是专门用于存放静态资源的，例如图片等等： 然后，启动SpringBoot，在浏览器中通过http://localhost:8080/timg.jpg即可访问： 5. 整合MyBatis如果在http://start.spring.io创建项目时，并没有添加MyBatis等依赖，则需要手动添加： &lt;!-- 整合MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;然后，还需要添加数据库的驱动： &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;注意：SpringBoot会自动使用最新版本的jar包，并不推荐自定义版本号，如果指定了版本，反而会提示警告： 然后，打开SpringBoot的配置文件src\main\resources\application.properties，添加数据库连接的相关配置： spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=root以上配置，将由SpringBoot自动读取，并注入到数据源对象中，所以，以上配置的各属性名必须是以上使用的这几个名称，不可以自行修改属性名。 开发持久层功能时，需要先创建接口，例如com.springboot.sample.mapper.UserMapper。此前使用传统的SSM开发时，需要在配置文件中指定接口所在的包，在SpringBoot中，可以为接口添加@Mapper注解，而无需添加配置。 @Mapper public interface UserMapper { }在添加完抽象方法之后，传统的SSM开发中需要继续配置XML映射，但是，在SpringBoot的应用中，可以直接添加注解： @Mapper public interface UserMapper { @Select(&quot;select id, password from t_user where username=#{username}&quot;) User findByUsername(String username); }不难发现，当执行的任务是查询时，则添加@Select注解，与之类似的还有@Insert、@Update、@Delete注解，根据需要执行的任务进行选取即可！ 当完成后，应该执行单元测试，可以自定义测试类，所有的测试类都应该添加注解： @RunWith(SpringRunner.class) @SpringBootTest public class 测试类 ...在编写测试方法时，所需要的对象如果是当前项目的组件，都可以自动装配： @RunWith(SpringRunner.class) @SpringBootTest public class UserMapperTestCase { @Autowired private UserMapper userMapper; // ...其它然后编写测试方法： @RunWith(SpringRunner.class) @SpringBootTest public class UserMapperTestCase { @Autowired private UserMapper userMapper; @Test public void findByUsername() { String username = &quot;mvc&quot;; User user = userMapper.findByUsername(username); System.out.println(user); username = &quot;hello&quot;; user = userMapper.findByUsername(username); System.out.println(user); } }至此，简单的持久层访问就已经完成！ 6. 业务层（非SpringBoot知识点）设计业务层方法时，以操作成功(操作正确)为前提来设计返回值的类型，而几乎每个业务方法都有出错的可能，出错时，直接抛出某种异常即可！ 以登录为例，方法名可以使用login，符合大多数人的英语认知；返回值应该是User，因为登录成功后，可能需要将用户的id、username等数据存入Session，则使用1个User对象可以封装这多项数据；参数应该使用String username和String password，简单易懂： User login(String username, String password);该方法可能出现的“错误”（指的是开发者认为用户操作失败）均通过抛出异常来表现，则调用方法时的语法可能是： try { User user = userService.login(&quot;&quot;, &quot;&quot;); session.setAttribute( &quot;id&quot;, user.getId()); session.setAttribute( &quot;username&quot;, user.getUsername()); } catch (Username异常 e) { } catch (Password异常 e) { }使用这种做法，既能满足返回正确的数据，又能体现多种不同的错误，并且，在语法上表达得也非常清楚！ 抛出的异常应该继承自RuntimeException，并添加父类中已经存在的多种构造方法，便于快速创建对象！通常，异常类存放在service的子级ex包中。 由于自定义的异常都是RuntimeException的子孙类异常，Java语法并不强制要求处理这些异常，则方法的调用者可能不清楚需要处理哪些异常，所以，在方法的声明中应该明确的抛出： public User login( String username, String password) throws UserNotFoundException, PasswordNotMatchException { // ... }并且，在方法的声明中明确的添加注释： /** * 用户登录 * @param username 用户名 * @param password 密码 * @return 成功登录的用户数据，包括用户的id等…… * @throws UserNotFoundException 用户数据不存在 * @throws PasswordNotMatchException 密码不匹配 */ public User login( String username, String password) throws UserNotFoundException, PasswordNotMatchException { // ... ... }7. 控制器层先创建com.springboot.sample.controller.UserController，添加@RestController注解，然后，添加方法处理请求： @RestController public class UserController extends BaseController { @Autowired private UserService userService; @RequestMapping(&quot;/login.do&quot;) public ResponseResult login( String username, String password) { User user = userService.login( username, password); return new ResponseResult(SUCCESS); } }并且，另行创建控制器的基类提供静态常量，并处理异常： public abstract class BaseController { protected static final int SUCCESS = 1; @ExceptionHandler(ServiceException.class) public ResponseResult handleException(Exception e) { // 判断异常的种类并进行处理 if (e instanceof UserNotFoundException) { return new ResponseResult(2, e); } else if (e instanceof PasswordNotMatchException) { return new ResponseResult(3, e); } return null; } }8. 复习思考题 为什么业务层的方法要抛出异常； 关于ResponseResult类，为什么需要多种不同的构造方法； 例如new ResponseResult(2, e)是什么意思； 处理请求的方法为什么返回ResponseResult ； 为什么自定义的异常需要是RuntimeException的子孙类； 业务层的方法为什么需要通过throws声明抛出异常； 为什么要将处理异常的代码编写在BaseController中； 处理异常时，@ExceptionHandler注解中可以不配置参数吗；]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax——异步操作、整合注册功能]]></title>
    <url>%2F2019%2F06%2F28%2Fajax%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E3%80%81%E6%95%B4%E5%90%88%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1. 整合整套注册流程1.1. 处理持久层复制此前项目的db.properties和spring-dao.xml到当前项目中，修改必要的配置，例如持久层接口所在的包。 在创建src\main\resources下创建mappers文件夹，复制并得到新的UserMapper.xml文件。 检查User实体类是否与数据表保持一致： public class User implements Serializable { private static final long serialVersionUID = 2905888894945816600L; private Integer id; private String username; private String password; private Integer age; private String phone; private String email; private Integer isDelete; private Integer department; // ... ...设计注册时需要执行的SQL语句： INSERT INTO t_user ( username, password, age, phone, email, is_delete, department ) VALUES ( #{username}, #{password}, #{age}, #{phone}, #{email}, #{isDelete}, #{department} ) 以上字段列表和值列表，每行（横排）都只写2个，便于检查；注意：最后一个字段和值的后面没有逗号，避免复制粘贴了多余的符号 为了保证“用户名唯一”，还应该添加“根据用户名查询数据”的功能，对应的SQL语句是： SELECT id, password FROM t_user WHERE username=#{username} 单从注册来看，查询的字段列表是无所谓的，只关心有没有匹配的数据即可，基于“根据用户名查询数据”功能还可以应用于“登录”，所以，查询字段中可以有密码，用于登录时判断密码，还可以有id，用于成功登录后存入Session。 所以，实现注册功能，至少需要执行2种SQL语句，那么，接口中也应该存在2个抽象方法！则创建cn.tedu.ajax.mapper.UserMapper接口，并添加抽象方法： Integer insert(User user); User findByUsername(String username);然后，修改UserMapper.xml根节点的namespace属性，并配置以上2个抽象方法的映射！ 1.2. 处理业务层业务层是持久层的调用者，且，大多数情况下，被控制器层调用。 Controller ---&gt; Service ---&gt; Mapper 在实际应用中，不允许控制器层直接调用持久层。 首先，创建cn.tedu.ajax.service.UserService类，声明private UserMapper userMapper;持久层对象，以便于调用并实现功能，但是，仅声明是没有值的，所以，添加@Autowired注解！如果属性需要被自动装配，当前类本身也应该在Spring管理范围之内，所以，当前类需要添加Service注解，并在组件扫描范围之内： @Service public class UserService { @Autowired private UserMapper userMapper; // ... ... 需要修改web.xml中加载的Spring配置文件，改为spring-*.xml。]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax——JSON数据、基于jquery的ajax]]></title>
    <url>%2F2019%2F06%2F20%2Fajax%E2%80%94%E2%80%94JSON%E6%95%B0%E6%8D%AE%E3%80%81%E5%9F%BA%E4%BA%8Ejquery%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[1. 响应方式在Java EE中，常见的响应方式有：转发和重定向。 无论是转发，还是重定向，都是由服务器端完成最终页面的显示，具体的表现为：用户提交请求后，页面完全由服务器端来完成！并且，伴随着页面的“刷新”！ 例如：当用户尝试登录时，假设用户名错误，只能转发到某个页面（可能是错误提示页面），或重定向到某个页面，无论是哪种操作，用户在浏览器中看到的都不会再是原有的页面了！ 使用这种做法，主要问题在于：(1)用户体验非常差；(2)服务器端压力较大，用户的请求次数也可能较多！(3)不适用于多种不同的客户端，例如PC端的浏览器、Android APP、iOS APP…… 其实，服务器端并不一定需要把页面都处理掉，更多的应该是告之客户端此次操作的结果，例如客户端尝试登录时，服务器端应该给出“登录成功”或“登录失败！用户名或密码错误！”此类的结果即可，至于界面如何处理，可以交给客户端程序（例如Javascript）去进行处理！ 如果需要响应的方式不是转发或重定向，而是直接响应一串字符，只需要在控制器处理请求的方式上添加@ResponseBody注解即可！ 使用该注解之前，应该在Spring的配置文件中添加&lt;mvc:annotation-driven /&gt;注解驱动。 例如： @Controller @RequestMapping(&quot;/user&quot;) public class UserController { @GetMapping(&quot;/login.do&quot;) @ResponseBody public String handleLogin() { return &quot;LOGIN ERR.&quot;; } } 以上@GetMapping等效于@RequestMapping(method=RequestMethod.GET)，使用4.3或以上版本的Spring框架时可用。 使用@ResponseBody可以向客户端响应正文，而不是某个页面！ 2. JSON以用户登录为例，可能存在：(1)成功；(2)用户名错误；(3)密码错误。即：同一次请求得到的结果可能是以上3种当中的某1种，客户获取到响应内容后，必须能够作出区分，然后执行下一步的任务，例如：成功，则跳转到某个页面，错误，则提示信息。当客户端收到数据后，如果数据中既包含操作结果的代码，又包含相关提示信息，则是比较好的处理方案，例如： 1-登录成功！ 2-登录失败！尝试登录的用户名不存在！ 3-登录失败！密码错误！以上组织数据的方式并不严谨，为了更好的组织数据，可以使用XML语法： &lt;data&gt; &lt;state&gt;1&lt;/state&gt; &lt;message&gt;登录成功！&lt;/message&gt; &lt;/data&gt;使用XML组织数据可以很好的约定数据的格式，保证能够正确的获取到所需的数据内容！但是，这样的语法格式比较笨重，解析相对麻烦，目前，比较推荐的是使用JSON格式来组织数据： { &quot;state&quot;:1, &quot;message&quot;:&quot;登录成功！&quot; }JSON格式不仅简单，而且，在Javascript中，是默认直接识别并解析的，例如： var data = { &quot;state&quot;:1, &quot;message&quot;:&quot;登录成功！&quot; }; alert(data.message); // 使用警告框显示messageJSON的基本格式 JSON数据的基本格式是：使用大括号框住所有内容，内部可以有多个属性与值，属性与值使用冒号分隔，各属性及值的配置之间使用逗号分隔，如果值是字符串型的，需要使用单引号或双引号框住，如果值是数值型或布尔型则不需要使用引号。 练习：使用JSON表达某个用户数据，姓名为张三，来自北京，年龄25。 var user = { &quot;name&quot;:&quot;张三&quot;, &quot;from&quot;:&quot;北京&quot;, &quot;age&quot;:25 }; alert(user.name);属性的值也可以是另一个对象 每个属性的值，可以是直接表示出来的基本值，也可以是另一个对象，对象的表示方式与整个JSON的表示方式是一样的。 例如：用户数据中包括“部门”，而部门信息有编号与名称。 var user = { &quot;name&quot;:&quot;张三&quot;, &quot;department&quot;:{&quot;id&quot;:&quot;9527&quot;, &quot;name&quot;:&quot;RD&quot;} }; alert(user.department.name);属性的值还可以是数组 在JSON中，和其它语言一样，使用[]表示数组。 例如：某用户的个人技能包含：JAVA / HTML / CSS / JS / MYSQL var user = { &quot;name&quot;: &quot;张三&quot;, &quot;skill&quot;: [&quot;JAVA&quot;, &quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;, &quot;MYSQL&quot;] } alert(user.skill[2]); for (var i = 0; i &lt; user.skill.length; i++) { alert(user.skill[i]); }属性的值的组合应用 属性的值可以是基本值（数值、布尔值、字符串），也可以是某个对象，或是某个数组，甚至，当值是某个对象时，对象中还可以再包含对象或数组，当然，数组的成员也可以是对象，基于这种特性，JSON可以组织出任何类型的数据！ 将字符串转换为JSON对象 在Javascript中，通过JSON.parse(str)就可以将字符串转换为JSON对象，当然，字符串本身必须是符合JSON数据格式的！ var jsonString = &apos;{ &quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;: 25 }&apos;; var json = JSON.parse(jsonString);小结 掌握JSON的数据格式，及数据的使用方式，掌握将字符串转换为JSON对象。 3. 服务器向客户端响应JSON格式的字符串添加依赖： &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt;当处理请求的方法添加@ResponseBody后，处理请求的方法的返回值将作为响应正文，响应到客户端，如果返回值类型是SpringMVC默认识别的类型，将直接处理，例如String，如果返回值类型是SpringMVC默认不识别的类型，将自动调用Jackson，将返回值组织成JSON数据格式！ 除此以外，Jackson还会设置响应头为：application/json, charset=utf-8，也就解决了中文乱码的问题！ 通常会在服务器端创建专门用于确定响应结果的数据类型，例如： public class ResponseResult { private Integer state; private String message; // SET/GET, Serializable }然后，每次向客户端响应时，都使用ResponseResult作为方法的返回值！ 4. AJAXAJAX是通过Javascript发出异步请求，并处理响应结果的做法！ 原生的AJAX使用比较麻烦，还可能存在兼容性的问题，所以，推荐使用jQuery框架中封装好的函数来实现AJAX访问。 由jQuery提供的AJAX请求函数是$.ajax()，参数是1个JSON对象，在该JSON对象中，通常，至少需要设置5个属性： url：将请求提交到哪里去，相当于中的action data：请求参数，参数格式为xx=xx&amp;xx=xx&amp;xx=xx type：请求类型，例如&quot;GET&quot;或&quot;POST&quot;等 dataType：服务器端响应的数据类型，取值可以是&quot;text&quot;、&quot;xml&quot;、&quot;json&quot; success：当服务器正确响应时（响应码=200）如何处理，取值为函数，由该函数对结果进行处理，可以在函数中添加1个参数，该参数就是服务器响应的内容，如果前序将dataType设置为&quot;json&quot;，则参数就是直接是JSON对象，无需实现JSON.parse()转换！ 使用例如： function login() { var u = $(&quot;#username&quot;).val(); var p = $(&quot;#password&quot;).val(); $.ajax({ &quot;url&quot;: &quot;user/login.do&quot;, &quot;data&quot;: &quot;username=&quot; + u + &quot;&amp;password=&quot; + p, &quot;type&quot;: &quot;POST&quot;, &quot;dataType&quot;: &quot;json&quot;, &quot;success&quot;: function(json) { if (json.state == 1) { // 登录成功 location.href = &quot;index.html&quot; } else if (json.state == 2) { // 用户名错误 alert(json.message); } else if (json.state == 3) { // 密码错误 alert(json.message); } } }); } &lt;/script&gt;]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中String、数组、日期、正则对象]]></title>
    <url>%2F2019%2F06%2F19%2FJavaScript%E4%B8%ADString%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[课程回顾 引入js三种： 在元素内部通过事件属性添加js代码 通常写的都是方法的调用 在&lt;head&gt;里面添加&lt;script&gt;标签 在标签体内写js代码 在单独的js文件中写代码，然后通过&lt;script&gt;标签的src属性引入*.js文件 数据类型： 数值类型 number 字符串类型 string 布尔值类型 Boolean 未定义类型 undefined 对象类型 object 遍历声明和赋值 var x = 10; x=”abc”; x=true/false; var y; 类型之间隐式转换 字符串： 转数值，能转直接转 不能转则转NaN；转布尔值 “”-&gt;false 其它true 数值：转字符串，直接转，转布尔值 0和NaN转false 其它true 布尔值：转数值 false-&gt;0 true-&gt;1 字符串直接转 undefined： 字符串直接转 转数值NaN 转布尔值false null：转字符串直接转 转数值0 转布尔值false 运算符，==先统一类型再比较 ===先比较类型 如果相等再比较值 typeof 18 + 5 = “number5” 除法会根据结果自动转换整数和小数 语句，写条件的地方如果不是布尔值会自动转成布尔值，for循环 int i改成var i 不支持增强for循环 方法声明 function 方法名(name,age){return xxx;} var 方法名 = function(name,age){return xxx;} 页面相关内容 通过id获取元素对象： var x = document.getElementById(“div1”); 获取文本框的值和设置文本框的值input.value = “abc”;var x = input.value; 给div添加文本内容 div.innerText=”abc”; 给div添加HTML内容 div.innerHTML=”“; 九宫格练习 代码参见demo01几行几列练习 代码参见demo02String 数组 日期对象 正则 String相关内容 创建字符串的两种方式 var s1 = “abc”; //单引号和双引号都可以 var s2 = new String(“abc”); 把字符串转成数值 parseInt(str)//把字符串转成整数，还可以把小数转成整数 parseFloat(str)//把字符串转成小数 Number(str)//等效parseFloat 字符串转大小写 str.toUpperCase()//转大写 str.toLowerCase()//转小写 获取字符串出现的位置 从0开始 var str = “abcdefgem”; -从前面找 str.indexOf(&quot;e&quot;); -从后面找 str.lastIndexOf(&quot;e&quot;); 截取字符串 从0开始 str.substring(start,[end]); 替换字符串 `str.replace(old,new); color var x = ““; x.replace(“[c]”,color);` 拆分字符串 str.split(“.”); //返回值是个数组 数值相关：四舍五入 18.23456.toFixed(4); // 18.2346 数组相关 创建数组 数组内部可以添加任意类型的数据 var arr1 = [“小明”,18,true]; var arr2 = new Array(); 往数组中添加内容 arr2.push(“张学友”); arr2.push(28); arr2.push(true); 修改数组的长度 arr1.length = 2; 遍历数组 for(var i=0;i&lt;arr1.length;i++){ alert(arr1[i]); } 数组反转 arr.reverse(); 数组排序 默认排序方式是以字符串的形式进行排序 排序规则是通过Unicode编码进行排序 arr.sort(); 自定义排序： //自定义排序需要准备一个自定义的排序方法 function sortfn(a,b){ return a-b;//升序 //return b-a;//降序 } alert(arr.sort(sortfn)); 日期相关函数 服务器时间和客户端时间 获取客户端时间 var d1 = new Date(); 2018/9/30 14:35:32 把字符串时间转成时间对象 var d2 = new Date(&quot;2018/9/30 14:35:32&quot;); 从时间对象中获取和设置时间戳（距离1970年1月1日 08：00：00） d2.getTime(); d2.setTime(1000); 1970/1/1 08:00:01 获取时间分量 单独的年 月 日 时 分 秒 星期几 d1.getFullYear(); d1.getMonth();//从0开始 d1.getDate(); d1.getDay();//星期 d1.getHours(); d1.getMinutes(); d1.getSeconds(); 获取年月日 获取时分秒 d1.toLocaleTimeString(); d1.toLocaleDateString();正则表达式. :匹配任意字符除了换行\w:匹配任意数字、字母、下划线\d:匹配任意数字\s:匹配空白^: 开头$: 结尾 应用场景：1. 查找内容 2. 校验文本 //第一种创建方式：第一个/代表的是规则 //第二个参数表示模式 //（i:忽略大小写 g:全局查找） var reg1 = /^a/i; //以a开头 忽略大小写 //以m结尾 reg1 = /m$/; //包含两个数字 reg1 = /\d{2}/; //以3个数字开头 reg1 = /^\d{3}/; //以y开头m结尾中间包含5位数字 reg1 = /^y\d{5}m$/; //6-10位数字字母下划线 reg1 = /^\w{6,10}$/; //第二种创建方式第一个参数是格式，第二个是模式 //第二个参数如果没有值可以省略 var reg2 = new RegExp(“^\w{6,10}$”); //和正则相关的方法 //1. 查找内容 var str = “you can you up no can no b b”; var reg = /no/g; //查找内容 如果全局查找 每执行一次查找一个 //执行第二次查找下一个 找不到时得到null //alert(reg.exec(str));//no //alert(reg.exec(str));//no //alert(reg.exec(str));//null //2. 校验方法 //reg = /^You/i; //alert(reg.test(str)); //字符串和正则相关的方法 //3. 查找内容 一次性得到所有查找内容 //var arr = str.match(reg); //alert(arr); //4. 查找替换 替换所有 alert(str.replace(reg,”bu”));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript概述、JavaScript基础语法]]></title>
    <url>%2F2019%2F06%2F19%2FJavaScript%E6%A6%82%E8%BF%B0%E3%80%81JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript 简称JS 用于给页面添加动态效果或动态内容的 JS历史：1995年由网景(NetScape)公司发布 LiveScript 同年改名为JavaScript，和Java没有关系，为了蹭热度。 语音特点： 属于脚本语言不需要编译，由浏览器解析执行，JavaScript可以嵌套在html中 ，基于面向对象，弱类型的语言, 交互性：可以用户直接交换，安全性：该语言只能访问浏览器里面的内容如何在html页面中引入JavaScript 在元素的事件属性中，如按钮的点击事件 &lt;input type=&quot;button&quot; value=&quot;点我试试！&quot; onclick=&quot;alert(&#39;试试就试试！&#39;)&quot;&gt; 在script标签中写js代表 script标签可以写在页面的任何位置 推荐写在head里面 &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;第二种引入方式！&quot;); &lt;/script&gt; 在单独的js文件中写js代码 通过script标签中的src属性引入，引入过文件的script标签不能在标签体中 继续写js代码 &lt;script type=&quot;text/javascript&quot; src=&quot;first.js&quot;&gt;&lt;/script&gt; JavaScript语法数据类型，变量，运算符，语句，方法（函数） 数据类型 数值类型(number) NaN (Not a Number) isNaN(18)= false isNaN(“abc”)=true 字符串类型(string) 布尔值类型(boolean) 未定义类型(undefined) 对象类型(object)变量的声明和赋值 var x = 18; //类型为number 值 18var name = “张三”; //类型string 值 张三var b = true/false; //类型Boolean 值 true/falsevar y; //类型是undefined 值 undefinedvar p = new Person(); 数据类型之间的隐式转换 js中数据类型会根据不同的场景进行自动类型转换 数值类型 转字符串： 直接转 18-&gt;”18” “abc”+18 = “abc18” （只有加法会把数值转字符串） 转布尔值: 0和NaN转false 非0即真(true) 字符串类型 转数值: 能转直接转 不能转则转成NaN； （NaN和任何数值进行任何运算结果都是NaN） “35”-&gt;35 “abc”-&gt;NaN 转布尔值: 只有空字符串(“”) 转false 其它true “”-&gt;false, “a”-&gt;true 布尔值类型 转数值： true=1 false=0 30+true=31 30+false=30 转字符串： 直接转 “abc”+true = “abctrue” undefined类型 转数值： NaN 转字符串： “undefined” 转布尔值： false null 转数值：0 28+null=28 转字符串： “null” “abc”+null = “abcnull” 转布尔值： false运算符 JS语言中的运算符和Java中大致相同 ==和===，==会先将等号两端的类型统一然后再比较值，===先判断类型是否相等如果不等则直接false如果相等再比较值是否相等 typeof typeof 66+6 =”number6” 两数相除 结果会自动生成整数或小数 5/2=2.5 4/2=2语句 if else while do while for switch case JS语言中的语句和Java中大致相同 语句中写条件的括号中如果不是布尔值类型会自动转成布尔值 for循环中 int i 改成 var i 不支持增强for循环（foreach)函数(方法)声明Java中声明函数的写法public String run(int age,String name){ return “abc”;} JS中写法 `function run(age,name){return &quot;abc&quot;; }` 格式一： function 方法名(参数列表){ return xxx; } 格式二： var 方法名 = function(参数列表){ return xxx; } 和页面相关的函数 通过id得到页面中元素的函数 var input = document.getElementById(&quot;myinput&quot;); 从文本框中获取内容和设置内容 input.value = &quot;abc&quot;; alert(input.value); 给div设置文本内容 d.innerText=&quot;abc&quot;; 给div设置html内容 d.innerHTML+= &quot;&lt;h1&gt;abc&lt;/h1&gt;&quot;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis占位符的使用、动态SQL]]></title>
    <url>%2F2019%2F06%2F17%2FMybatis%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[1. MyBatis中的占位符在MyBatis中，常见的占位符格式是#{参数}，其中，也可能是参数对象中的属性，如果参数是Map类型，还可以是Map中的key。 使用#{}的占位符可用于替换值，例如： select * from t_user where username=?即可替换以上语句中的问号(?)，在实际运行时，MyBatis会将以上SQL语句进行预编译，并后续使用#{}替换问号(?)。 假设获取用户列表时，排序规则不确定，可能使用的抽象方法是： List&lt;User&gt; findAllOrderedList(String orderBy);配置的映射可能是： &lt;select id=&quot;xx&quot; resultType=&quot;xx&quot;&gt; select * from t_user order by #{orderBy} &lt;/select&gt;调用时： mapper.findAllOrderedList(&quot;id asc&quot;); mapper.findAllOrderedList(&quot;id desc&quot;);以上代码的执行效果是失败的！需要将#{}修改为${}，且在抽象方法中，这样的参数必须添加@Param注解，即： List&lt;User&gt; findAllOrderedList( @Param(&quot;orderBy&quot;) String orderBy); &lt;select id=&quot;xx&quot; resultType=&quot;xx&quot;&gt; select * from t_user order by ${orderBy} &lt;/select&gt;然后，在调用时，就可以根据参数的不同，实现不同的排序效果！ 使用${}格式的占位符并不具备预编译的效果！它是直接拼接形成的SQL语句，例如：&quot;select * from t_user order by&quot; + orderBy，如果一定使用${}格式的占位符来表示某个值，还需要考虑单引号类似的问题，例如：select * from t_user where username=&#39;${username}&#39;，由于只是拼接，所以，还存在SQL注入风险！ 小结 使用#{}是预编译的（没有SQL注入风险，无需关注数据类型），使用${}不是预编译的； 使用#{}只能替换某个值，使用${}可以替换SQL语句中的任何部分； 关于SQL注入，不需要太过于紧张，预编译可以从根源上杜绝，或者，在执行SQL指令之前，判断参数中是否包含单引号也可以杜绝！ 通过使用${}，可以使得SQL更加灵活，更加通用！但是，却不推荐太过于通用的SQL！因为，即使查询条件可以自由更改，但是，不同的查询条件对应不同的需求，所需的字段列表很有可能是不一样的，查询时，获取不必要的字段，就会造成不必要的资源浪费，例如，显示列表时，可能需要用户名、密码、年龄、手机、邮箱，但是，登录的查询就只需要用户名、密码即可，年龄、手机、邮箱这几项数据在登录时是不需要的，如果也查询出来，就是浪费资源！如果变量太多，又会导致不可控因素太多，容易出错！ 2. 动态SQL在MyBatis的映射文件中，配置SQL语句时，可以添加例如&lt;if&gt;此类的标签，实现SQL语句的动态变化，即：参数不同，最终执行的SQL语句可能是不同的！ 在使用动态SQL时，最常用的就是&lt;if&gt;和&lt;foreach&gt;这两种，&lt;if&gt;是用于判断的，例如： select * from t_user &lt;if test=&quot;where != null&quot;&gt; where ${where} &lt;/if&gt; &lt;if test=&quot;orderBy != null&quot;&gt; order by ${orderBy} &lt;/if&gt;关于&lt;foreach&gt;，主要用于循环处理SQL语句中的某个部分，例如：批量删除某些数据！它的SQL语句可能是： delete from t_user where id in (?,?,?)其中，in关键字右侧的括号中的内容是不确定的，应该是由用户操作时决定的！则需要&lt;foreach&gt;动态的生成这个部分！ 针对这个问题，设计的抽象方法可能是： Integer deleteByIds(Integer[] ids);配置的映射为： &lt;delete id=&quot;deleteByIds&quot;&gt; delete from t_user where id in ( &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; ) &lt;/delete&gt;以上配置的&lt;foreach&gt;中，collection表示被遍历的集合对象，当抽象方法只有1个参数时，取值为list或array，取决于集合对象的数据类型，当抽象方法 有多个参数时，使用@Param注解中的名称，item表示遍历过程中的变量名，separator表示分隔符。 以上配置还可以调整为： id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt;即：open表示由&lt;foreach&gt;处理的SQL语句的起始部分的字符串，而close表示结束部分的字符串。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis获取自增主键值、使用多个参数、关联查询]]></title>
    <url>%2F2019%2F06%2F16%2FMybatis%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E5%80%BC%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E3%80%81%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1. 执行插入数据时获取自增长的id当需要获取新增的数据的id时，首先，需要在&lt;insert&gt;节点中添加2个属性： useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;以上配置中，useGeneratedKeys表示获取自增长的键（自增长的字段的值），keyProperty表示键的属性名，即对应的类中的属性名（即该id是User类中的id，并非t_user表中的id）！ 添加以上配置之后，插入数据操作的返回值依然表示“受影响的行数”，但是，用于执行插入操作的参数对象中就会包含自动生成的id值，例如，调用时的代码： System.out.println(&quot;增加前：&quot; + user); Integer rows = userMapper.insert(user); System.out.println(&quot;rows=&quot; + rows); System.out.println(&quot;增加后：&quot; + user);结果例如： 增加前：User [id=null, username=jsd1808, password=1234, age=31, phone=13900139008, email=jsd1808@tedu.cn] rows=1 增加后：User [id=24, username=jsd1808, password=1234, age=31, phone=13900139008, email=jsd1808@tedu.cn]可以记住：在配置时，需要配置4个属性。 2. 使用多个参数功能设定：将t_user表中年龄大于xx的数据的密码修改为xx 分析所执行的SQL语句： update t_user set password=? where age&gt;?抽象方法： Integer updatePasswordByAge( Integer age, String password);SQL映射： &lt;update id=&quot;updatePasswordByAge&quot;&gt; update t_user set password=#{password} where age&gt;#{age} &lt;/update&gt;直接调用，会报告错误： org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &apos;password&apos; not found. Available parameters are [arg1, arg0, param1, param2] Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;password&apos; not found. Available parameters are [arg1, arg0, param1, param2]因为.java文件在编译后变成.class文件就会丢失参数名称，在最终执行的.class文件中，根本就不存在名为password或age的参数，所以，程序会报错，可行的解决方法是把多个参数封装到一个Map中，这样的话，此前使用的方法名称例如age或password就会变成Map的key，是一些字符串，并不会因为编译而丢失，最终运行就不会有问题，当然，每次运行时都需要自行将参数封装为Map，操作麻烦，还存在key拼写错误的风险，所以，MyBatis提供了@Param注解以解决这个问题： 解决多个参数的问题：可以将多个参数封装为1个Map，或封装为1个自定义的数据类型，但是，更推荐使用@Param注解。 3. 关于resultMap使用resultMap可以解决名称不匹配的问题！例如在数据表中存在is_delete字段，则实体类存在isDelete属性，则数据表中使用的名称与实体类中的属性名不一致！ 前置操作： alter table t_user add column is_delete int default 0; update t_user set is_delete=1 where id in (11,13,15);然后，在User类中添加private Integer isDelete;及SET/GET方法，重新生成toString()。 名称不匹配的问题可以通过自定义别名来解决，例如： &lt;select id=&quot;findAll&quot; resultType=&quot;cn.tedu.mybatis.entity.User&quot;&gt; select id, username, password, age, phone, email, is_delete AS isDelete from t_user &lt;/select&gt;也就是：MyBatis的要求是“查询结果中的列名与返回值类型的属性名必须一致”，通过自定义别名就可以满足这个要求，并不需要通过&lt;resultMap&gt;来实现！ 通常，需要自定义&lt;resultMap&gt;时，主要用于解决多表数据关联查询的问题。 例如： create table t_department ( id int auto_increment, name varchar(20) not null, primary key(id) ); insert into t_department (name) values (&apos;UI&apos;), (&apos;RD&apos;), (&apos;TEST&apos;); alter table t_user add column department int;通常实体类都是与数据表一一对应的，符合设计规范，但不适用于多表的关联查询，例如当需要“查询某个部门信息的同时需要获取该部门的所有员工的信息”，则没有任何数据类型可以匹配这样的信息，为了解决这样的问题，通常会定义VO类，即Value Object类，这种类型是专用于解决实体类不满足使用需求而存在的，类的设计结构与实体类非常相似，但是，属性的设计是完全根据使用需求来决定的，例如： public class DepartmentVO { private Integer depId; private String depName; private List&lt;User&gt; users; // SET/GET方法，toString()，序列化接口 }普通的查询无法得到以上结果，查询语句可能是： select t_user.id, username, password, age, phone, email, is_delete, t_department.id AS dep_id, name from t_user, t_department where t_user.department=t_department.id and t_department.id=?以上查询易于理解，通俗易懂，但是，不推荐使用，更推荐使用JOIN系列的查询语法： SELECT t_user.id, username, password, age, phone, email, is_delete, t_department.id AS dep_id, name FROM t_user INNER JOIN t_department ON t_user.department=t_department.id WHERE t_department.id=?这样的查询结果可能有好几行， 需要有效的封装到1个对象中，就必须依靠&lt;resultMap&gt;来设计封装的规则： &lt;!-- id：节点的唯一标识 --&gt; &lt;!-- type：数据类型 --&gt; &lt;resultMap id=&quot;DepartmentVoMap&quot; type=&quot;cn.tedu.mybatis.vo.DepartmentVO&quot;&gt; &lt;!-- id节点：主键的配置 --&gt; &lt;!-- column：查询结果的列名 --&gt; &lt;!-- property：数据类型的属性名 --&gt; &lt;id column=&quot;dep_id&quot; property=&quot;depId&quot;/&gt; &lt;!-- 其它结果的配置 --&gt; &lt;result column=&quot;name&quot; property=&quot;depName&quot;/&gt; &lt;!-- 配置List集合 --&gt; &lt;!-- ofType：集合中放的哪种类型的数据 --&gt; &lt;collection property=&quot;users&quot; ofType=&quot;cn.tedu.mybatis.entity.User&quot;&gt; &lt;!-- 自此开始，property表示User中的属性名 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;配置方式可参考： 最后，应用时，与普通的数据操作相同，先添加接口与抽象方法： public interface DepartmentMapper { DepartmentVO findById(Integer id); }然后配置映射： &lt;select id=&quot;findById&quot; resultMap=&quot;DepartmentVoMap&quot;&gt; SELECT t_department.id AS dep_id, name, t_user.id, username, password, age, phone, email, is_delete FROM t_user INNER JOIN t_department ON t_user.department=t_department.id WHERE t_department.id=#{id} &lt;/select&gt;最终，执行查询获取的结果例如： DepartmentVO [ depId=2, depName=RD, users=[ User [id=13, username=spring, password=1234, age=23, phone=13800138003, email=spring@tedu.cn, isDelete=1, department=null], User [id=14, username=mybatis, password=12cxv34, age=24, phone=13800138004, email=mybatis@tedu.cn, isDelete=0, department=null], User [id=17, username=jdbc, password=88888888, age=27, phone=13800138007, email=jdbc@tedu.cn, isDelete=1, department=null], User [id=21, username=mapper, password=88888888, age=31, phone=13900139001, email=mapper@tedu.cn, isDelete=1, department=null], User [id=23, username=namespace, password=88888888, age=31, phone=13900139002, email=namespace@tedu.cn, isDelete=1, department=null] ] ]如果提示错误TooManyResultsException，则错误多半在于查询结果的列名与&lt;resultMap&gt;中普通的&lt;id/&gt;或&lt;result/&gt;节点的column的配置有误！也有可能存在例如2列的名称都是id，却有多条数据的id值不同的问题！ 练习：存在学生表和班级表，学生表t_student中包括id, name, age, class_id，班级表t_class中包括id, name，最终，查询时，查某班级数据时将显示该班级所有学生的信息。涉及的类为Student、Clazz。 练习步骤1：创建2张数据表，插入一定量的数据，创建对应的实体类，创建班级的VO类： create table t_class ( id int auto_increment, name varchar(20), primary key (id) ); insert into t_class (name) values (&apos;JSD1806&apos;),(&apos;JSD1807&apos;),(&apos;JSD1808&apos;); create table t_student ( id int auto_increment, name varchar(20), age int, class_id int, primary key (id) ); insert into t_student (name,age,class_id) values (&apos;Mike&apos;, 20, 1), (&apos;Tom&apos;, 21, 2), (&apos;Terry&apos;, 21, 3), (&apos;Jerry&apos;, 22, 2), (&apos;Lucy&apos;, 22, 1), (&apos;Kitty&apos;, 22, 2), (&apos;Lily&apos;, 21, 3), (&apos;Lilei&apos;, 20, 3), (&apos;HanMM&apos;, 23, 3), (&apos;XiaoMing&apos;, 21, 2);练习步骤2：创建cn.tedu.mybatis.mapper.ClazzMapper接口，复制得到src\main\resources\ClazzMapper.xml映射文件，这2个文件都是空文件即可。 练习步骤3：设计SQL语句： SELECT t_class.id AS cls_id, t_class.name AS cls_name, t_student.id AS stu_id, t_student.name AS stu_name, age, class_id FROM t_class INNER JOIN t_student ON t_class.id=t_student.class_id WHERE t_class.id=?;练习步骤4：抽象方法 ClazzVO findById(Integer id);练习步骤5：配置&lt;select&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;ClazzVOMapper&quot;&gt; SELECT t_class.id AS cls_id, t_class.name AS cls_name, t_student.id AS stu_id, t_student.name AS stu_name, age, class_id FROM t_class INNER JOIN t_student ON t_class.id=t_student.class_id WHERE t_class.id=#{id}; &lt;/select&gt;练习步骤6：配置&lt;resultMap&gt; &lt;resultMap id=&quot;ClazzVOMapper&quot; type=&quot;cn.tedu.mybatis.vo.ClazzVO&quot;&gt; &lt;id column=&quot;cls_id&quot; property=&quot;clsId&quot;/&gt; &lt;result column=&quot;cls_name&quot; property=&quot;clsName&quot;/&gt; &lt;collection property=&quot;student&quot; ofType=&quot;cn.tedu.mybatis.entity.Student&quot;&gt; &lt;id column=&quot;stu_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;stu_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;class_id&quot; property=&quot;classId&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;课后练习：新添加考试成绩表t_score，包括字段id(int)、stu_id(int), subject(varchar), score(int)，要求最终实现：根据学生id查询出该学生的所有成绩，例如： XX学生成绩单 学号：xx 姓名：xx 序号 | 科目 | 分数 1 Java 80 2 SQL 70]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis概念、配置连接、配置映射、查询操作]]></title>
    <url>%2F2019%2F06%2F13%2FMyBatis%E6%A6%82%E5%BF%B5%E3%80%81%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E3%80%81%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. MyBatis1.1. 作用MyBatis是持久层框架，它是支持JDBC的！简化了持久层开发！ 使用MyBatis时，只需要通过接口指定数据操作的抽象方法，然后配置与之关联的SQL语句，即可完成！ 持久化存储：在程序运行过程中，数据都是在内存（RAM，即内存条）中的，内存中的数据不是永久存储的，例如程序可以对这些数据进行销毁，或者由于断电也会导致内存中所有数据丢失！而把数据存储到硬盘中的某个文件中，会使得这些数据永久的存储下来，常见做法是存储到数据库中，当然，也可以使用其它技术把数据存储到文本文件、XML文件等其它文件中！ 1.2. 基本使用1.2.1. 创建项目使用此前相同的创建流程即可！注意：请检查有没有多余的配置，如果有，请删除，例如在spring.xml是否存在拦截器的配置！ 此次使用MyBatis框架，所以，需要添加新的依赖： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; 如果下载的依赖jar包是损坏的，应该先关闭Eclipse，然后删除对应的jar包文件，再次启动Eclipse，对项目点击右键，选择Maven &gt; Update Project，并且在弹出的对话框中勾选Force Update ...选项即可。 MyBatis是一个独立的框架，即只添加该依赖就可以实现持久层编程，但是，开发过程相对比较繁琐，而实际应用中，通常会与Spring、SpringMVC一起使用，整合使用时，可以简化大量的配置，使得开发更加简便！整合时，还需要添加相关依赖： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;整合的SSM框架是基于JDBC的，所以，还需要添加spring-jdbc的依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;添加以上依赖时，直接将此前的spring-webmvc的依赖代码复制一次，将spring-webmvc改成spring-jdbc即可！凡是Spring官方（Group ID是org.springframework）推出的以spring-作为前缀的依赖，必须使用相同的版本，否则，可能存在不兼容的风险！ 在实现过程中，肯定得先建立与数据库的连接，然后再继续编程，所以，还应该添加数据源管理的依赖，即数据库连接池的依赖： &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;由于本次将使用MySQL数据库，所以，还需要该数据库的连接驱动的依赖： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.8&lt;/version&gt; &lt;/dependency&gt;1.2.2. 创建数据库与数据表创建数据库tedu_mybatis： CREATE DATABASE tedu_mybatis;创建数据表t_user： CREATE TABLE t_user( id INT AUTO_INCREMENT, username VARCHAR(20) UNIQUE NOT NULL, password VARCHAR(20) NOT NULL, age INT, phone VARCHAR(20) , email VARCHAR(30), PRIMARY KEY(id) ) DEFAULT CHARSET=UTF8;1.2.3. 配置数据源在src\main\resources下创建db.properties文件，用于配置与数据库连接相关的信息： url=jdbc:mysql://localhost:3306/tedu_mybatis?useUnicode=true&amp;characterEncoding=utf8 driver=com.mysql.jdbc.Driver username=root password=root initialSize=2 maxActive=10以上配置的值以自己使用的数据库为准！ 以上配置需要被应用到项目中，则在Spring的配置中通过&lt;util:properties /&gt;可以读取该文件： &lt;!-- 读取db.properties --&gt; &lt;util:properties id=&quot;dbconfig&quot; location=&quot;classpath:db.properties&quot; /&gt;最后，需要把这些配置应用到数据源（数据库连接池）中，当前项目使用的是Apache的commons-dbcp，则对应的数据源是BasicDataSource类： &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;#{dbconfig.url}&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;#{dbconfig.driver}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;#{dbconfig.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;#{dbconfig.password}&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;#{dbconfig.initialSize}&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;#{dbconfig.maxActive}&quot; /&gt; &lt;/bean&gt;完成以上配置后，可以测试到目前为止的配置是否正确，做法就是：获取BasicDataSource的对象，调用它的getConnection()方法，尝试在Java程序中获取与数据库的连接，如果能够正常连接，则配置无误，如配置有误，将无法获取连接： @Test public void getConnection() throws SQLException { AbstractApplicationContext ac = new ClassPathXmlApplicationContext( &quot;spring.xml&quot;); BasicDataSource ds = ac.getBean(&quot;dataSource&quot;, BasicDataSource.class); Connection conn = ds.getConnection(); System.out.println(conn); ac.close(); }1.2.4. 通过MyBatis插入数据MyBatis的编码模式是： 创建接口，并声明数据访问的抽象方法； 配置与抽象方法对应的XML映射。 首先，创建cn.tedu.mybatis.entity.User实体类，并添加与t_user数据表匹配的属性。在实体类中， 有相同数量的属性 数据类型应该保持一致 属性名称与字段名应该一一对应（在Java中的属性名称应该采用驼峰命名法，而数据库领域中并不区分大小写） 所有的属性都应该是私有的 且都存在公有的SET/GET方法 整个实体类应该是实现了Serializable接口的！ 通常，每张数据表都有一个与之匹配的实体类！ 创建cn.tedu.mybatis.mapper.UserMapper接口，并在接口中声明抽象方法： Integer insert(User user);在MyBatis中，执行insert/update/delete操作时，均返回受影响的行数，所以，设计抽象方法时，如果对应的是这几种操作，返回值均设计为Integer类型。 通常，一个完整的项目中，会存在许多MyBatis的映射文件，为了便于管理，会在src\main\resources下创建一个名为mappers的文件夹，然后，下载共享的SomeMapper.zip，将解压得到的XML文件复制到刚才创建的mappers文件夹中： 其实，在mappers下的映射文件的名称并不重要！但是，为了便于管理，通常会使用与接口对应的名称，所以，将SomeMapper.xml重命名为UserMapper.xml。 所有映射文件中，根节点都是&lt;mapper&gt;节点，且该节点必须配置名为namespace的属性，属性值是对应的Java接口，例如： &lt;mapper namespace=&quot;cn.tedu.mybatis.mapper.UserMapper&quot;&gt; &lt;/mapper&gt;经过以上配置，指定了XML映射文件与接口文件的对应关系。 然后，在该文件内部，使用各级子节点配置与抽象方法的对应关系，子节点名称的选取，取决于要执行的操作的类型，例如要执行的数据操作是insert类型，则使用&lt;insert&gt;节点，这些节点都必须指定id属性，属性值是与之对应的抽象方法的方法名： &lt;!-- id：抽象方法的名称 --&gt; &lt;insert id=&quot;insert&quot;&gt; &lt;/insert&gt;在&lt;insert&gt;节点中，添加parameterType属性，用于指定参数的类型，即抽象方法中的参数类型： &lt;!-- id：抽象方法的名称 --&gt; &lt;!-- parameterType：抽象方法中的参数的类型 --&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;cn.tedu.mybatis.entity.User&quot;&gt; &lt;/insert&gt; 然后，在节点内部，编写需要执行的SQL语句： &lt;!-- id：抽象方法的名称 --&gt; &lt;!-- parameterType：抽象方法中的参数的类型 --&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;cn.tedu.mybatis.entity.User&quot;&gt; INSERT INTO t_user ( username, password, age, phone, email ) VALUES ( #{username}, #{password}, #{age}, #{phone}, #{email} ) &lt;/insert&gt;执行SQL语句时的参数值均使用#{}类似的语法，其中的名称是User类中的属性名： 1.2.5. 最后的配置首先，需要配置SqlSessionFactoryBean，通过它指定数据源与XML映射的文件位置： &lt;!-- SqlSessionFactoryBean --&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 指定数据源，值为以上配置的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 指定XML映射文件的位置 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot; /&gt; &lt;/bean&gt;以上配置中，XML映射文件的位置使用了mappers/*.xml，即：在mappers文件夹下的所有XML文件都应该是MyBatis的映射文件，所以，后续使用时，不可以在这个文件夹中存放其它XML文件。 然后，还需要配置MapperScannerConfigurer，用于指定接口文件在哪里： &lt;!-- MapperScannerConfigurer --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定接口文件的位置 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.tedu.mybatis.mapper&quot; /&gt; &lt;/bean&gt; 至此，配置完成！ 1.2.6. 执行单元测试在src\test\java下创建测试类，并添加测试方法，以执行测试： @Test public void insert() { // 加载Spring配置文件，获取Spring容器 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( &quot;spring.xml&quot;); // 从Spring容器中获取对象 // bean-id与接口名一致，首字母为小写 UserMapper userMapper = ac.getBean(&quot;userMapper&quot;, UserMapper.class); // 测试功能 User user = new User(); user.setUsername(&quot;root&quot;); user.setPassword(&quot;1234&quot;); Integer rows = userMapper.insert(user); System.out.println(&quot;rows=&quot; + rows); // 释放资源 ac.close(); }1.2.7. 小结关于配置 使用MyBatis添加了一些新的依赖，及一些配置，这些属于固定的一次性操作，在后续的项目中，每个项目中只需要做1次即可。 关于这些配置，需要记住配置的作用，及可能需要修改的位置，至少包括： db.properties的文件名，因为&lt;util:properties&gt;需要使用它； 在db.properties中配置的值，重点是数据库名称、访问数据库的密码，在更换项目或更换计算机后都可能需要调整； 在配置SqlSessionFactoryBean时指定的映射文件的位置； 在配置MapperScannerConfigurer时指定的接口文件所在的包； 关于开发 每张数据表，都应该有1个与之对应的实体类； 每种数据（视为每个实体类）的处理都应该有对应的接口文件，例如项目中有User实体类，则应该有UserMapper接口； 在接口中声明抽象方法时，如果最终将执行insert/delete/update操作，返回值类型应该是Integer； 每个持久层接口，都应该有对应的XML映射文件，例如有UserMapper.java接口，就应该有UserMapper.xml文件； 在配置XML文件内部，根据执行操作选择节点，如果执行的是insert操作，则通过&lt;insert&gt;节点进行配置； 在XML映射中，每个节点都必须配置id属性，取值是接口中抽象方法的名称，由于id具有唯一的特性，所以，在接口中声明抽象方法时，不要使用重载； 在配置SQL语句时，使用#{}表示预编译时的?对应的值，括号中的名称是参数名称，或参数对象中的属性名称； 当执行delete/update时，配置的节点不需要指定parameterType属性。 1.2.8. 删除指定的数据设置目标为根据id删除指定的数据。 先在接口中声明抽象方法： Integer deleteUserById(Integer id);然后，在XML映射中配置以上方法对应的节点： &lt;delete id=&quot;deleteUserById&quot;&gt; DELETE FROM t_user WHERE id=#{id} &lt;/delete&gt;然后，执行单元测试： @Test public void deleteUserById() { // 加载Spring配置文件，获取Spring容器 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( &quot;spring.xml&quot;); // 从Spring容器中获取对象 // bean-id与接口名一致，首字母为小写 UserMapper userMapper = ac.getBean(&quot;userMapper&quot;, UserMapper.class); // 测试功能 Integer id = 3; Integer rows = userMapper.deleteUserById(id); System.out.println(&quot;rows=&quot; + rows); // 释放资源 ac.close(); }——————————-作业 完成根据用户名删除数据的功能； 完成将所有用户的密码设置为某个值的功能； 完成删除用户表中所有数据的功能。 在MyBatis中，默认不允许添加2个参数，否则会报错，解决方案待续。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC拦截器、乱码问题、异常处理]]></title>
    <url>%2F2019%2F06%2F10%2FSpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[【回顾】作业在今天的案例基础之上，实现： 如果注册时，提交的用户名是root，将视为用户名已经被占用，提示错误页面； 如果注册成功，跳转到登录页面； 如果登录时，提交的用户名是root，且密码是1234，则跳转到主页（请求路径为/main/index.do，显示的页面是index.jsp），如果登录错误，根据错误类型在错误页面提示“用户名不存在”或“密码错误” 练习 设计/user/info.do请求，响应方式是转发到user_info.jsp页面，页面中使用文字标识是该页面即可 设计/user/password.do请求，响应方式是转发到user_password.jsp页面，页面中使用文字标识是该页面即可 在主页(/main/index.do)中添加超链接，点击后分别进入以上2个页面。 以上2个页面，必须登录以后，才允许访问，如果没有登录时尝试访问这2个页面，将直接重定向到登录页。 分析 如何判断用户已经登录？可以在用户登录成功的情况下，通过Session记录用户的相关信息，然后，当需要判断是否登录时，直接判断Session中是否存在对应的信息即可！ Session中存储哪些数据 用户的唯一标识，例如用户的ID； 使用频率非常高的数据，例如用户的用户名、昵称、头像等； 其它不便于使用其它技术存储的数据…… 1. SpringMVC中的拦截器（Interceptor）1.1. 作用拦截器是运行在DispatcherServlet之后，在每个Controller之前的，且运行结果可以选择放行或拦截！ 除此以外，拦截器还会运行在Controller之后，关于拦截器，在处理某一个请求时，最多有3次执行！只不过，通常关注最多的是第1次执行，即在Controller之前的那次！ 1.2. 基本使用需要自定义类，例如名为LoginInterceptor，实现HandlerInterceptor接口，重写3个抽象方法： public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;LoginInterceptor.preHandle()&quot;); return false; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;LoginInterceptor.postHandle()&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;LoginInterceptor.afterCompletion()&quot;); } }拦截器需要在Spring的配置文件中进行配置后才可以生效！所以，需要添加配置： &lt;!-- 配置拦截器链 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 配置第1个拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 指定拦截路径，不在拦截路径之内的将不予处理，即拦截器根本就不运行 --&gt; &lt;mvc:mapping path=&quot;/user/info.do&quot;/&gt; &lt;mvc:mapping path=&quot;/user/password.do&quot;/&gt; &lt;!-- 指定拦截器类 --&gt; &lt;bean class=&quot;cn.tedu.spring.interceptor.LoginInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;在拦截器类中，运行在Controller之前的是preHandle()方法，该方法返回true表示放行，返回false表示拦截！ 对于登录拦截器而言，可以判断Session中的用户数据，如果数据存在，视为已登录，可直接放行，如果没有数据，则视为没登录，需要重定向，并拦截： public boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;LoginInterceptor.preHandle()&quot;); // 判断Session中的数据，得知是否登录 HttpSession session = request.getSession(); if (session.getAttribute(&quot;username&quot;) == null) { // Session中没有用户名，即：没有登录，则：重定向，并拦截 response.sendRedirect(&quot;../user/login.do&quot;); // 返回false表示拦截 return false; } // 返回true表示放行 return true; }在配置拦截器时，根节点是&lt;mvc:interceptors&gt;，用于配置拦截器链，即任何一个SpringMVC项目，都可以有若干个拦截器，从而形成拦截器链，如果某个请求符合多个拦截器的拦截配置，则会依次被各拦截器进行处理，任何一个拦截，都会导致后续不再将请求交给Controller去处理！ 在&lt;mvc:interceptors&gt;（有s）节点子级，可以配置多个&lt;mvc:interceptor&gt;（没有s）子级节点，表示多个拦截器，拦截器链的执行顺序取决于这里各节点的配置先后顺序！ 在&lt;mvc:interceptor&gt;中，&lt;bean&gt;节点用于指定拦截器类；&lt;mvc:mapping&gt;节点，用于配置拦截的请求路径，每个拦截器可以配置多个该节点，并且，在配置时，支持使用星号*作为通配符，例如：&lt;mvc:mapping path=&quot;/user/*&quot;/&gt;，为了避免拦截范围过大，可以通过&lt;mvc:exclude-mapping /&gt;配置排除在外的请求路径，可以理解为白名单，该节点也可以配置多个： &lt;!-- 配置拦截器链 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 配置第1个拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 指定拦截路径，不在拦截路径之内的将不予处理，即拦截器根本就不运行 --&gt; &lt;mvc:mapping path=&quot;/user/*&quot; /&gt; &lt;!-- 指定白名单，列举的请求路径将不予处理，即拦截器根本就不运行 --&gt; &lt;mvc:exclude-mapping path=&quot;/user/reg.do&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/user/login.do&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/user/handle_reg.do&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/user/handle_login.do&quot; /&gt; &lt;!-- 指定拦截器类 --&gt; &lt;bean class=&quot;cn.tedu.spring.interceptor.LoginInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;注意：以上配置黑名单或白名单时，都可以使用星号*作为通配符，但是，它只能匹配1层路径（或者说只能通配任意资源）！例如配置的是/user/*，可以匹配/user/reg.do或/user/login.do，却无法匹配到/user/a/reg.do或/user/a/b/login.do这样的路径！如果需要匹配多层路径，可以使用2个星期，即**，例如配置/user/**则可以匹配以上任意路径！ 2. 乱码2.1. 关于乱码在处理中文或非ASCII字符（需要使用输入法才可以输入的）时，如果存、取时，使用的字符编码不统一，就会出现乱码！ 所以，出现乱码原因就是因为字符编码不统一，而解决问题的方案就是使用统一的编码！ 需要统一编码的位置有：项目源码、数据库、处理数据的服务端组件、数据传输过程、#显示界面 2.2. 解决控制器中接收请求参数的乱码通常，在Java EE项目中，解决问题的方式是： request.setCharacterEncoding(&quot;utf-8&quot;);由于Controller是运行在DispatcherServlet之后的，在Controller内部再执行更改编码格式已经晚了，事实上SpringMVC框架在DispatcherServlet之前就存在CharacterEncodingFilter可以确定请求与响应的编码格式，所以，在SpringMVC中，无法通过Controller或Interceptor来解决请求和响应的乱码问题。 在SpringMVC框架的CharacterEncodingFilter中，把使用的字符编码设计为变量，可以在web.xml中添加配置加以应用，来统一设置编码： &lt;!-- 配置字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;2.3. 拦截器与过滤器有什么区别拦截器是Interceptor，过滤器是Filter； 拦截器是SpringMVC中的组件，过滤器是Java EE中的组件； 拦截器是配置在Spring的配置文件中的，过滤器是配置在web.xml中的； 拦截器是运行在DispatcherServlet之后、Controller之前的，且在Controller执行完后还会调用2个方法，而过滤器是运行在所有的Servlet之前的； 拦截器的配置非常灵活，可以配置多项黑名单，也可以配置多项白名单，过滤器的配置非常单一，只能配置1项过滤路径； 拦截器与过滤器也有很多相似之处，例如：都可拒绝掉某些访问，也可以选择放行；都可以形成链。 相比之下，在一个使用SpringMVC框架的项目中，拦截器会比过滤器要好用一些，但是，由于执行时间节点的原因，它并不能完全取代过滤器！ 3. 异常3.1. 基本概念在Java中，异常的体系结构是： Throwable Error OutOfMemoryError Exception IOException FileNotFoundException SQLException UnsupportedEncodingException RuntimeException NullPointerException ClassCastException ArithmeticException IllegalArgumentException IndexOutOfBoundsException ArrayIndexOutOfBoundsException在这些异常中，RuntimeException及其子孙类异常，在Java语法中并不要求必须处理！主要的原因有：这些异常出现的频率可能非常高，如果一定要处理，例如try...catch，则几乎所有的代码都需要放在try代码块中！并且，这些异常是可以杜绝的异常，通过严谨的编程，可以保证这些异常绝对不会出现！ 处理异常有2种方式：使用try...catch处理异常，或者使用throw抛出异常对象，并且在方法的声明中使用throws语法声明抛出！ 通常，异常都是必须处理的，如果没有处理异常，会导致异常不断向上抛出，最终，Java EE中的异常会由Tomcat来处理，会把跟踪日志显示在页面中！而这些跟踪日志是普通用户看不懂的，对于专业人士而言，还可能分析出项目中的一些内容，对于后续解决问题也没有任何帮助，所以，从开发原则上来说，必须处理异常！ 3.2 处理异常-SimpleMappingExceptionResolver非RuntimeException是从语法上强制要求处理的，所以，每次调用了抛出异常的方法，就必须try...catch或继续声明抛出！ 而RuntimeException及其子孙类异常并不从语法上强制要求处理，但是，一旦出现，会项目的安全、用户体验等各方面都会产生负面影响！ SpringMVC提供了统一处理异常的方式：使用SimpleMappingExceptionResolver类，该类通过private Properties exceptionMappings;属性来配置异常种类与转发到的页面的对应关系，即每一种异常都可以有一个与之对应的页面，一旦项目中出现配置过的异常，就会自动转发到对应的页面来提示错误信息！ &lt;!-- 配置统一处理异常 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.RuntimeException&quot;&gt;runtime&lt;/prop&gt; &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;null&lt;/prop&gt; &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;index&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;这种方式处理异常非常的简单，但是，也有一个比较大的问题：无法提示更详细的信息！例如出现ArrayIndexOutOfBoundsException时，其实，异常对象中还封装了详细的错误信息，即：越界值是多少。 3.3 处理异常-@ExceptionHandler可以在控制器类中自定义一个处理异常的方法，在方法之前添加@ExceptionHandler，然后，凡是约定范围内的异常，都可以由该方法来决定如何处理： @ExceptionHandler public String handleException(Exception e) { System.out.println( &quot;ExceptionController.handleException()&quot;); if (e instanceof NullPointerException) { return &quot;null&quot;; } else if (e instanceof ArrayIndexOutOfBoundsException) { return &quot;index&quot;; } return &quot;runtime&quot;; }在处理异常时，如果需要转发数据，可以将返回值修改为ModelAndView，或者，在处理异常的方法参数列表中添加HttpServletRequest，但是，却不可以使用ModelMap来封装转发的数据： @ExceptionHandler public String handleException(Exception e, HttpServletRequest request) { System.out.println( &quot;ExceptionController.handleException()&quot;); if (e instanceof NullPointerException) { return &quot;null&quot;; } else if (e instanceof ArrayIndexOutOfBoundsException) { request.setAttribute(&quot;msg&quot;, e.getMessage()); return &quot;index&quot;; } return &quot;runtime&quot;; }思考：是否可以在类中添加3个处理异常的方法，分别只处理NullPointerException和ArrayIndexOutOfBoundsException和RuntimeException？ 答案：可以！允许使用多个不同的方法来处理异常！ 思考：假设处理异常的方法在A控制器中，而B控制器中处理请求时出现异常，会被处理吗？ 答案：不可以！通常，可以创建一个BaseController，作为当前项目的控制器类的基类，然后，把处理异常的代码编写在这个类中即可！ 关于@ExceptionHandler，还可以用于限制其对应的方法处理的异常的种类！例如： @ExceptionHandler(IndexOutOfBoundsException.class)以上代码表示接下来的方法只处理IndexOutOfBoundsException及其子孙类异常，而其它的异常并不处理！ 3.4 小结处理异常的本质并不可以“撤消”异常，无法让已经出现的问题还原到没有问题！所以，处理异常的本质应该是尽量的补救已经出现的问题，并且，尝试通过提示信息等方式告之使用者，尽量执行正确的操作，避免后续再次出现同样的问题！ 并且，对于开发者而言，应该处理每一个可能出现的异常，因为，如果没有处理，就会继续抛出，最终被Tomcat捕获，而Tomcat处理的方式是把异常的跟踪信息显示在页面上，是极为不合适的！ 在SpringMVC中，处理异常有2种方式，第1种是通过SimpleMappingExceptionResolver设置异常与转发目标的对应关系，第2种是使用@ExceptionHandler为处理异常的方法进行注解，推荐使用第2种方式。 通常，会把处理异常的方法写在项目的控制器类的基类中，即写在BaseController中，在使用@ExceptionHandler时，可以明确的指定所处理的异常类型，例如：@ExceptionHandler(NullPointerException)，且，在控制器类中，可以编写多个处理异常的方法！ 关于处理异常的方法，应该是public方法，返回值类型与处理请求的方式相同，可以是String或ModelAndView或其它允许的类型，方法的名称可以自定义，参数列表中必须包括Exception类型的参数，还允许存在HttpServletRequest、HttpServletResponse，不允许使用ModelMap。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC转发与重定向、Session、注解详解]]></title>
    <url>%2F2019%2F06%2F06%2FSpringMVC%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81Session%E3%80%81%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[【回顾】作业3. 创建新项目 SPRINGMVC-02-USER，要求对 /reg.do和 /login.do 能作出响应，响应方式是显示 reg.jsp 和 login.jsp 页面，并且，注册页（reg.jsp）要求有用户名、密码、年龄、手机、邮箱这5个输入项和1个提交按钮，而登录页（login.jsp）要求有用户名、密码这2个输入项和1个提交按钮，不要求页面之间可以跳转。注意：代码请排版！1. 接收请求参数1.1. 【不推荐】通过HttpServletRequest在处理请求的方法中，添加HttpServletRequest对象作为参数，在方法体中，直接调用参数对象的getParameter()或类似功能的方法，即可获取请求参数： @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg( HttpServletRequest request) { System.out.println(&quot;UserController.handleReg()&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); Integer age = Integer.valueOf(request.getParameter(&quot;age&quot;)); String phone = request.getParameter(&quot;phone&quot;); String email = request.getParameter(&quot;email&quot;); System.out.println(&quot;username=&quot; + username); System.out.println(&quot;password=&quot; + password); System.out.println(&quot;age=&quot; + age); System.out.println(&quot;phone=&quot; + phone); System.out.println(&quot;email=&quot; + email); return null; }1.2. 【推荐】在处理请求的方法中声明同名参数假设用户提交的参数是username=root，则参数名是username，当需要获取这个参数的值时，直接在处理请求的方法中声明String username即可，框架会把root值直接用于调用处理请求的方法，即String username的值就已经是root了： @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg( String username, String password, Integer age, String phone, String email) { System.out.println(&quot;[2] username=&quot; + username); System.out.println(&quot;[2] password=&quot; + password); System.out.println(&quot;[2] age=&quot; + (age + 1)); System.out.println(&quot;[2] phone=&quot; + phone); System.out.println(&quot;[2] email=&quot; + email); return null; }使用这种做法时，可以无视数据类型，例如希望age是Integer类型的，则直接声明为Integer类型即可，无须自行转换！ 使用这种做法时，必须保证提交的请求参数的名称，与处理请求的方法中的参数名称是一致的！如果不一致，则处理请求的方法中，对应的参数值会是null值！ 如果参数名称无法统一，后续有解决方案。 这种做法最大的缺陷是：不适用于数据项目太多的表单！否则，会导致处理请求的方法中需要添加大量的参数！ 1.3. 【推荐】使用自定义类型获取多项数据假设请求参数中包含多项数据，例如：username=admin&amp;password=123456&amp;age=22&amp;phone=13900139001&amp;email=admin%40tedu.cn，而这些数据都可以封装在同一个类型中，则直接使用该类型作为处理请求的参数即可： @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg(User user) { System.out.println(&quot;[3] username=&quot; + user.getUsername()); System.out.println(&quot;[3] password=&quot; + user.getPassword()); System.out.println(&quot;[3] age=&quot; + (1 + user.getAge())); System.out.println(&quot;[3] phone=&quot; + user.getPhone()); System.out.println(&quot;[3] email=&quot; + user.getEmail()); return null; }这种做法，适用于请求参数较多的场合！ 注意：如果请求参数的参数名称，与类中的属性名称不一致，则类对象中对应的属性值为null！ 注意：这种做法可以与前序介绍的第2种做法组合来使用！ 1.4. 小结关于获取请求参数，首先，并不推荐使用HttpServletRequest，主要原因是相对比较原始，编码比较繁琐！而声明同名参数，或声明对象，都是推荐的做法，至于使用哪一种，可以根据参数的数量及数据是否适合被封装到同一个类中，综合评定，并且，这2种做法可以组合使用！ 2. 控制器的响应2.1. 常见的响应方式【转发】在转发过程中，客户端只发出过1次请求！在浏览器的地址栏中，也只会显示第1次请求的路径！转发是在服务器内部完成的，可以传递数据！ 【重定向】当服务器响应重定向时，客户端会发出第2次请求！最终，在浏览器的地址栏中，会显示第2次请求的路径！由于是2次不同的请求，基于Http协议是无状态协议，没有经过特殊处理（Session/Cookie/数据库存取……）的数据是无法在2次请求之间传递的！ 2.2. 常见的响应码被服务器接收到的每个请求，在最终响应时，服务器端都会给出一个响应码，例如200、404等。通常： 2xx：正确的响应，例如200、206等…… 3xx：重定向，例如302、301等…… 4xx：请求错误，例如请求的资源不存在，或者请求类型错误、或者请求参数错误等等，例如400、404、405、406等…… 5xx：服务器内部错误，通常可能是出现某种异常，例如500等…… 3. 转发数据3.1. 【不推荐】将转发的数据封装在HttpServletRequest对象中可以为处理请求的方法添加HttpServletRequest request参数，当需要转发数据时，将数据封装在request中即可，后续也不需要显式的执行转发，在SpringMVC的控制器中，默认的响应方式就是转发。 @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg(User user, HttpServletRequest request) { // 假定输入的用户名已经被占用 // 提示：您输入的用户名XXX已经被占用 request.setAttribute(&quot;msg&quot;, &quot;您输入的用户名&quot; + user.getUsername() + &quot;已经被占用！&quot;); // 返回视图名，也可以理解为文件的文件名 return &quot;error&quot;; // 页面：/WEB-INF/error.jsp } 3.2. 【不推荐】使用ModelAndView可以将处理请求的方法的返回值设置为ModelAndView类型，该类型的常用构造方法有： ModelAndView() ModelAndView(String viewName) ModelAndView(String viewName, Map&lt;String, ?&gt; model)当需要转发数据时，可以使用以上3种中的最后一种： @RequestMapping(&quot;handle_reg.do&quot;) public ModelAndView handleReg(String username) { String viewName = &quot;error&quot;; Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); model.put(&quot;msg&quot;, &quot;[2] 您输入的用户名&quot; + username + &quot;已经被占用！&quot;); ModelAndView mav = new ModelAndView(viewName, model); return mav; }由于这种方式使用相对比较复杂，所以，一般不推荐使用这种做法！ 3.3. 【推荐】使用ModelMap封装需要转发的数据使用ModelMap的流程与使用HttpServletRequest完全相同，即：方法的返回值依然使用String类型，在方法中声明该参数，然后在方法体中直接封装数据，最后，返回视图名： @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg(String username, ModelMap modelMap) { modelMap.addAttribute(&quot;msg&quot;, &quot;[3] 您输入的用户名&quot; + username + &quot;已经被占用！&quot;); return &quot;error&quot;; }3.4. 小结在SpringMVC中，转发数据共有3种做法，第1种使用HttpServletRequest的做法简单直接，但是，并不推荐这样处理，主要是因为框架已经帮我们处理了request需要执行的任务，而我们在编写代码时应该尽量不干预框架的处理过程，第2种使用ModelAndView，是框架的核心处理方式，但是，因为使用方式过于麻烦，所以，也不推荐这样使用，第3种使用ModelMap，使用简洁，推荐使用。 3.5. 附：重定向在SpringMVC中，当需要重定向时，首先，应该保证处理请求的方法的返回值是String类型（与转发一样），然后，返回值使用redirect:作为前缀即可，例如： @RequestMapping(&quot;handle_reg.do&quot;) public String handleReg() { // 假设注册成功，需要登录 return &quot;redirect:login.do&quot;; }需要注意的是：在redirect:右侧的不是视图名，而是重定向的目标的路径，可以是绝对路径，也可以是相对路径。 当处理的请求的返回值类型是String时，如果返回值使用redirect:作为前缀，是重定向，否则，是转发！ 4. 关于@RequestMapping注解通过配置@RequestMapping，可以绑定请求路径与处理请求的方法，例如： @RequestMapping(&quot;login.do&quot;) public String showLogin() { ...即：通过以上配置，当接收到login.do请求时，SpringMVC会自动调用showLogin()方法。 除了在方法之前添加该注解以外，该注解还可以添加在控制器类的声明之前，例如： @RequestMapping(&quot;user&quot;) @Controller public class UserControler { ...当方法之前添加了该注解之后，方法内配置的所有请求路径，在最终访问时都必须添加user路径，例如：http://localhost:8080/SPRINGMVC-02-USER/user/reg.do。 通常，推荐在类之前也添加该注解，方便管理路径，例如在某个新闻管理的应用中，可能存在news_list.do、news_info.do的请求，而在这个应用中，也会有用户数据，就存在user_list.do、user_info.do，可以发现，为了保证请求路径是唯一的，都需要在路径之前添加xxx_作为前缀，这样的管理方式是非常不方便的，在类之前添加@RequestMapping注解就可以很好的解决这个问题，每个路径之前根本就不需要配置前缀字符，也不会发生冲突！ 在@RequestMapping的使用过程中，路径可以使用/作为第1个字符，也可以不需要这个字符，例如： /user /login.do user login.do /user login.do user /login.do以上4种配置都是正确的！通常，推荐使用/作为第1个字符，即以上第1种方式！ 除了配置请求路径以外，使用@RequestMapping还可以限制请求方式，即某个路径可以设置为只允许POST请求，而不接收GET请求！ 【GET】会将请求的参数与值体现在URL中；请求的参数与值会受到URL长度限制，不适用于传递大量的数据； 【POST】请求的参数与值不会体现在URL中；可以传递大量的数据； 【选取】请求的参数与值涉及隐私（例如密码）则必须使用POST；数据量可能较大时必须使用POST；需要共享URL且其中包含参数时必须使用GET；支持页面刷新必须使用GET。 【复杂度】如果要发出POST请求，只能通过&lt;form&gt;中的&lt;input type=&quot;submit&quot; /&gt;或&lt;button /&gt;，或者通过JS技术，否则，在Web领域无法发出POST请求，而这2种方式也都可以用于发出GET请求，除此以外，直接在浏览器中输入某个URL发出的也是GET请求，总的来说，发GET请求要简单得多。 【小结】参考以上“选取”原则，选择请求方式，如果两者均可，则使用GET即可。 在@RequestMapping中配置method属性可以限制请求类型： @RequestMapping(value=&quot;handle_reg.do&quot;, method=RequestMethod.POST) public String handleReg() {例如以上代码限制了handle_reg.do必须通过POST方式来请求，如果使用GET方式，则会返回405错误！ 只有需要限定请求方式时，才需要显式的配置value=”handle_reg.do”，否则，直接将”handle_reg.do”配置在注解中即可！ 小结：关于@RequestMapping注解，主要作用是配置请求路径，推荐在控制器类和处理请求的方法之前都添加该注解，类之前的注解是用于配置请求路径中的层次，方法之前的注解是用于配置请求的资源，关于路径的配置是该属性的value属性，如果只配置请求路径，可以不用显式的声明这是配置value属性，而是直接把值写出来即可，例如不需要写成@RequestMapping(values=&quot;login.do&quot;)，而可以直接写成@RequestMapping(&quot;login.do&quot;)，在配置路径时，推荐使用/作为第1个字符，例如@RequestMapping(&quot;/login.do&quot;)，如果还需要限制请求方式，则必须显式的声明路径为value属性的值，并且添加配置method属性，例如：@RequestMapping(value=&quot;handle_reg.do&quot;, method=RequestMethod.POST)。 5. 关于@RequestParam注解使用@RequestParam注解，可以解决请求参数名称与处理请求的方法的参数名称不一致的问题，例如： public String handleLogin( @RequestParam(&quot;name&quot;) String username, String password) { ...则请求参数的名称是name，而处理请求的方法中的参数名称却是username，这是可以正常运行的！ 一旦使用了@RequestParam注解，默认情况下，参数就是必须的！例如配置了@RequestParam(&quot;passwd&quot;) String password后，如果请求中并不存在名为passwd的参数，则会出现400错误： HTTP Status 400 - Required String parameter &apos;passwd&apos; is not present没有提交名为passwd的参数，与提交了空值，是两码事！即：如果提交了passwd参数却没有值（例如输入框中没有输入值），在服务器将得到空字符串（””），程序并不会出现错误！如果根本就没有提交名为passwd的参数，则会导致400错误！ 如果使用了@RequestParam注解，却又不想设置为必须提交该参数，可以： @RequestParam(value=&quot;name&quot;, required=false)则将根据name去接收参数，如果有值，会正确接收，如果没有（没有提交该名称的参数），则会是null值！ 当required=false时，意味着可以不必提交该参数，还可以多配置一项defaultValue属性(The default value to use as a fallback when the request parameter value is not provided or empty. Supplying a default value implicitly sets required() to false.)，表示如果请求中没有提交该参数，则默认值是多少！例如： @RequestParam(value=&quot;passwd&quot;, required=false, defaultValue=&quot;888999&quot;) String password以上代码表示：希望请求中包含名为passwd的参数，如果有，则值用于方法的String password的参数，如果没有，也不是必须要提供（required=false），并且使用&quot;888999&quot;作为默认值（defaultValue=&quot;888999&quot;），即：在这种情况下，String password的值是&quot;888999&quot;。 小结：@RequestParam注解是用于处理请求的方法中的参数之前，可以配置3项属性，分别是value表示请求参数名称，required表示请求中是否必须包含该参数，defaultValue表示参数的默认值，当有以上任何一种需求时，都需要配置该注解，即：请求参数名称与处理请求的方法的参数名称不一致；强制必须提交某个参数；为某个参数配置默认值。 ————————————作业在今天的案例基础之上，实现： 如果注册时，提交的用户名是root，将视为用户名已经被占用，提示错误页面； 如果注册成功，跳转到登录页面； 如果登录时，提交的用户名是root，且密码是1234，则跳转到主页（请求路径为/main/index.do，显示的页面是index.jsp），如果登录错误，根据错误类型在错误页面提示“用户名不存在”或“密码错误”]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP概念、JAVA代码片段、隐含对象、指令、JSP表达式、日期输出、HTML转换JSP]]></title>
    <url>%2F2019%2F06%2F06%2FJSP%E6%A6%82%E5%BF%B5%E3%80%81JAVA%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%81%E9%9A%90%E5%90%AB%E5%AF%B9%E8%B1%A1%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81JSP%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%97%A5%E6%9C%9F%E8%BE%93%E5%87%BA%E3%80%81HTML%E8%BD%AC%E6%8D%A2JSP%2F</url>
    <content type="text"><![CDATA[1.jsp(1)jsp是什么?sun公司制订的一种服务器端动态页面技术规范。 注： 虽然使用Servlet也可以生成动态页面，但是过于 繁琐(需要使用out.println语句)，并且不利于页面的 维护(比如，要修改页面就必须修改java代码),所以,sun 才制订了jsp技术规范。 jsp其实是一个以.jsp为后缀的文件，主要内容是 html和少量的java代码。容器会将jsp文件转换成一个对应的servlet然后执行。 jsp的本质就是一个servlet。(2)如何写一个jsp文件?step1. 添加一个以.jsp为后缀的文件。 step2. 在该文件里面，可以使用如下元素: 1)html(css,javascript)直接写即可。2)java代码方式一 java代码片断 &lt;% java代码 %&gt; 方式二 jsp表达式 &lt;%= java表达式 %&gt;3)隐含对象a.什么是隐含对象? 直接可以使用的对象，比如out、request、response。 b.为什么可以直接使用这些隐含对象? 因为容器会自动添加获得这些对象的语句。4)指令a.什么是指令? 通知容器，在将jsp文件转换成一个Servlet类时， 做一些的额外的处理，比如导包。 b.指令的语法 &lt;%@ 指令名 属性=值 %&gt; c.page指令 import属性：用于指定要导的包名。 比如 &lt;%@ page import=&quot;java.util.*,java.text.*&quot;%&gt; contentType属性：设置response.setContentType方法的内容。 pageEncoding属性:告诉容器，在读取jsp文件的内容时，使用指定的字符集来解码。 (3)jsp是如何执行的?1)阶段一 容器将.jsp文件转换成一个Servlet类。html(css,js) ----&gt; service方法里面，使用out.write输出。 &lt;% %&gt; -----&gt; service方法里面，照搬。 &lt;%= %&gt; -----&gt; service方法里面，使用out.print输出。2)阶段二 容器调用该Servlet需要编译、实例化、然后调用service方法。练习 写一个date.jsp，输出当前的系统日期，比如输出 &quot;2018-10-31&quot;]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重定向、DAO的概念及编写]]></title>
    <url>%2F2019%2F06%2F06%2F%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81DAO%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[1.重定向(1)什么是重定向?服务器通知浏览器向某个地址发送请求。 注： 服务器可以发送302状态码和Location消息头 (该消息头的值是一个地址，一般称之为重定向 地址)给浏览器，浏览器收到之后，会立即向 重定向地址发送请求。 (2)如何重定向?response.sendRedirect(String url); 注: url是重定向地址。 容器在重定向之前，会清空response对象上存放的 所有数据。(3)特点a.重定向之后，浏览器地址栏的地址会发生改变。 b.重定向的地址是任意的。 2. DAO (Data Access Object)(1)DAO是什么?是一个封装了数据访问逻辑的对象。 (2)如何写一个DAO?step1.写一个java类(一般称之为实体类)。 注： 该类与要访问的表的结构保持一致，即 表有哪些字段，该类要有与之对应的属性，属性 类型要与表的字段类型匹配。 我们可以将记录中保存的信息添加到实体对象 里面，方便处理。 public class User { private int id; private String username; private String pwd; private String email; @Override public String toString() { return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, pwd=&quot; + pwd + &quot;, email=&quot; + email + &quot;]&quot;; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } }step2.写一个java类，提供一些访问数据库的方法。 public class UserDAO { /** * 查询出所有用户的信息。 * 注： * 关系数据库里面存放的是一条条记录， * 而java是面向对象的语言。在设计 * DAO时，我们经常将查询到的记录转换成 * 一个对应的java对象。 */ public List&lt;User&gt; findAll() throws Exception{ List&lt;User&gt; users = new ArrayList&lt;User&gt;(); Connection conn = null; PreparedStatement stat = null; ResultSet rs = null; try { conn = DBUtils.getConn(); String sql = &quot;SELECT * FROM t_user&quot;; stat = conn.prepareStatement(sql); rs = stat.executeQuery(); while(rs.next()) { int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String pwd = rs.getString(&quot;password&quot;); String email = rs.getString(&quot;email&quot;); User user = new User(); user.setId(id); user.setUsername(username); user.setPwd(pwd); user.setEmail(email); users.add(user); } } catch (Exception e) { e.printStackTrace(); throw e; }finally { DBUtils.close(conn, stat, rs); } return users; } }3)DAO的优点a.DAO封装了数据访问逻辑，调用者不用关心数据访问逻辑是如何实现的。这样，代码更好维护。 b.方便测试。如果将数据访问写在servlet里面，需要部署整个应用才能测试。]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Dao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC概念及执行流程]]></title>
    <url>%2F2019%2F06%2F05%2FSpringMVC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SpringMVC框架1. 作用解决了V-C的交互问题，即视图与控制器的交互问题。 在原生的Java EE技术中，使用Servlet作为项目中的控制器，用于接收用户的请求，并给予响应结果。这种做法最大的问题在于：在常规做法中，每个Servlet对应1个请求路径，例如LoginServlet处理login.do的请求，而RegisterServlet处理register.do的请求，所以，会导致Servlet数量太多，不便于管理（无论从源文件的数量，还是从配置文件的内容），且对象太多进而占用大量内存空间的问题！ 并且，在请求的处理过程中，还存在许多操作不简便的做法！ 1.2. SpringMVC核心组件 DispatcherServlet 前端控制器，主要职责是接收所有请求（根据配置文件来决定），并将请求转发给对应的控制器，接收控制器的处理结果，确定最终由哪个视图完成响应！ HandlerMapping 处理请求路径与控制器的映射关系。 Controller 实际处理请求的组件，例如接收请求参数，决定最终是转发或重定向的方式来响应。 ModelAndView 控制器的处理结果，其中的Model表示转发的数据（如果是重定向，则Model没有意义），而View表示最终负责响应的视图组件的名称。 ViewResolver 根据视图组件的名称，确定具体使用的是哪个视图组件。 1.3. SpringMVC-HelloWorld1.3.1. 创建项目创建Maven Project，勾选Create a simple project，然后，Group Id值为cn.tedu.spring，Artifact Id值为SPRINGMVC-01-HELLOWORLD，Packaging选择war： 接下来，需要执行4个步骤（以后每次创建项目时都需要做的事情）： 生成web.xml文件； 添加依赖：在此前的项目中找到pom.xml，将其中的依赖的代码复制到当前项目中，关于依赖的jar包，会越用越多，学习时，只加不减； 复制spring.xml文件到当前项目中，并删除其中的配置，除非你确定这些配置是当前项目中必须使用的； 为项目添加Tomcat运行环境； 1.3.2. 配置DispatcherServlet由于需要DispatcherServlet接收所有请求，所以，首先必须在web.xml配置它： &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;经过以上配置，则任何以.do作为后缀的请求，都将由DispatcherServlet来处理！ 由于项目是基于Spring的，希望项目启动时就加载Spring的配置文件，并使得DispatcherServlet已经完成初始化可以随时接收请求，所以，还需进一步的配置： &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置spring的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动Tomcat时即初始化该Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;至此，当项目启动时，就会初始化DispatcherServlet，并且，在初始化过程中，会加载Spring的配置文件。 测试 如果Spring能正常工作，则配置是成功的！ 在src\main\java中创建一个测试类cn.tedu.spring.test.Test，并且，显式的添加构造方法，并输出内容： @Component public class Test { public Test() { System.out.println(&quot;已经加载Spring配置文件！&quot;); } }然后，在Spring的配置文件中添加组件扫描： &lt;context:component-scan base-package=&quot;cn.tedu.spring&quot; /&gt;最终，把项目部署到Tomcat，并启动Tomcat，在启动日志中如果能够看到以上输出语句，则成功！ 1.3.3. 设计目标发出请求http://localhost:8080/项目名称/hello.do，要求在界面中显示HelloWorld字样。 1.3.4. 处理请求以上完成了流程中的第1步，接下来，如果发出hello.do请求，就会被DispatcherServlet接收得到，然后，DispatcherServlet应该根据hello.do请求路径去询问HandlerMapping得知由哪个控制器去处理请求，原始的实现方式是使用SimpleUrlHandlerMapping类去进行配置，不过，这种配置方式非常麻烦，而且，对应关系不明确（所有的路径与控制器的配置都在同一个配置文件中，导致不便于管理），所以，后续都是使用注解完成相关配置，则在开发过程中，跳过第2步和第3步（只是开发时不用关注，框架的执行流程不变）。 为了确保有控制器处理请求，所以，创建HelloController： 所有的控制器都应该是由Spring管理的，所以，需要为控制器类添加@Controller注解： @Controller public class HelloController { }然后，在类中自定义处理请求的方法，方法的访问权限是public的，返回值暂时使用String，方法的名称可以自由定义，方法的参数暂时留空： public String showHello() { }在SpringMVC中，请求对应的可以是某个方法，而不一定每个请求对应一个控制器类，如果请求对应的是以上方法，则需要在方法的声明之前添加@RequestMapping(&quot;/hello.do&quot;)： @RequestMapping(&quot;/hello.do&quot;) public String showHello() { }完成以上步骤后，即表示：路径为/hello.do的请求将触发showHello()方法被执行！ 测试 在以上方法中输出任意语句，然后，启动项目，请求对应的路径，观察控制台输出： @RequestMapping(&quot;/hello.do&quot;) public String showHello() { System.out.println( &quot;HelloController.showHello()&quot;); return null; }实际运行效果是：页面会显示错误： 控制台可以看到输出语句： 1.3.5. 显示页面至此，执行流程已经完成前4步，接下来，控制器应该向DispatcherServlet返回结果： @RequestMapping(&quot;/hello.do&quot;) public String showHello() { // 测试 System.out.println( &quot;HelloController.showHello()&quot;); // 返回视图组件的名称 return &quot;helloworld&quot;; }以上返回的字符串表示最终负责显示的视图组件的名称，但是，并不表示是哪个文件！ 接下来，需要配置ViewResolver，使得DispatcherServlet通过它可以知道刚才控制器返回的&quot;helloworld&quot;到底是哪个页面！ 实际使用的ViewResolver是InternalResourceViewResolver，需要在spring.xml进行配置： &lt;!-- 配置视图解析器ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;/bean&gt;InternalResourceViewResolver的工作方式是以项目的根路径为参考（在开发时，对应的是webapp文件夹），使用前缀+视图组件名+后缀得到视图文件的位置，例如实际存在的jsp文件是webapp/WEB-INF/helloworld.jsp，由于它本身使用webapp作为根级，所以，前缀是/WEB-INF/，后缀是.jsp，结合控制器返回的&quot;helloworld&quot;进行拼接，就可以得到以上路径，从而确定视图组件的位置，例如配置为： &lt;!-- 配置视图解析器ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot; /&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;!-- 经过以上配置后， --&gt; &lt;!-- 当前项目中的jsp文件都应该放在/WEB-INF/下 --&gt; &lt;/bean&gt;基于视图解析器的前缀是/WEB-INF/，后缀是.jsp，结合控制器返回的&quot;helloworld&quot;字符串，则需要在WEB-INF文件夹下创建名为helloworld.jsp的文件完成最终的显示： 通过浏览器再次访问，实际效果应该是： 1.3.6. 小结 本案例中关于web.xml中的DispatcherServlet的配置，和spring.xml中的InternalResourceViewResolver的配置，是相对固定的配置，在后续的项目开发时，可以直接复制使用，但是，注意理解配置的值的意义； 处理请求的方法的声明语句应该例如：public String xx() 处理请求的方法的返回值可以理解为JSP文件的文件名； ——————————–作业1. 把笔记中HelloWorld的开发流程读一遍2. 参考springmvc.png流程图，口述SpringMVC的工作流程3. 创建新项目 SPRINGMVC-02-USER，要求对 /reg.do和 /login.do 能作出响应，响应方式是显示 reg.jsp 和 login.jsp 页面，并且，注册页（reg.jsp）要求有用户名、密码、年龄、手机、邮箱这5个输入项和1个提交按钮，而登录页（login.jsp）要求有用户名、密码这2个输入项和1个提交按钮，不要求页面之间可以跳转。注意：代码请排版！]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring组件扫描、注解]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%E3%80%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 前2天小结 【理解】通过Spring获取对象的3种条件：无参构造方法、静态工厂方法、实例方法； 【理解】由Spring管理的对象的作用域及生命周期：单例、懒加载、生命周期方法； 【重要】通过SET方式注入属性的值，理解value和ref的使用； 【了解】通过构造方法注入属性的值； 【了解】注入集合类型的属性的值，包括：List / Set / Map； 【重要】注入Properties类型的属性的值，读取*.properties文件； 【理解】自动装配的作用，取值为byName与byType的特性； 【重要】Spring表达式 2. Spring注解（Annotation）2.1. 基本概念例如@Override就是注解，在Spring中定义了一些注解，可以取代在Spring的XML文件中的配置！ 2.2. 通过Spring获取对象案例目标：创建cn.tedu.spring.dao.UserDao类，然后，创建cn.tedu.spring.test.SpringTest类，通过Spring获取UserDao的对象。 在Spring中，有几种通用注解： @Component @Controller @Service @Repository 这些注解是添加在类的声明之前的，表示这个类是一个“组件”，是希望由Spring进行管理的！ 以上4个注解中，@Component表示“通用组件类”，@Controller表示“控制器类”，@Service表示“业务类”，@Repository表示“数据访问类/持久层处理的类”，这4个注解只有语义的区别，从功能和用法上来说，是完全一样的！即，如果愿意的话，可以用@Service注解添加在控制器类的声明之前，但是，不推荐这样做。 仅仅只是添加注解是不够的，还需要在Spring的配置文件中开启组件扫描： &lt;context:component-scan base-package=&quot;cn.tedu.spring.dao&quot; /&gt;以上配置中，base-package表示根包，即当配置为cn.tedu.spring时，其子级包例如cn.tedu.spring.dao或cn.tedu.spring.service等都在扫描范围之内！ 如果没有显式的指定bean-id，默认为使用类名且首字母改为小写，例如UserDao类的bean-id就是userDao。 以上注解都可以添加配置，例如@Service(&quot;bean-id&quot;)。 小结：通用注解共4个，其功能、用法都是完全相同的，只是表达的语义不同，添加的注解的类，并且在组件扫描范围之内，就会被Spring所管理，在配置组件扫描时，配置的包是“根包”，其范围不宜过大，在添加注解时，还可以自定义bean-id。 2.3. 作用域与生命周期由Spring管理的对象，默认是饿汉式的单例的，通过在类的声明之前添加注解@Lazy可以调整： @Component(&quot;userDao&quot;) @Lazy(true) public class UserDao { }还可以通过@Scope(&quot;singleton&quot;)或@Scope(&quot;prototype&quot;)注解调整是否为单例的： @Service @Scope(&quot;prototype&quot;) public class UserService { }关于生命周期方法，依然是先自定义生命周期方法，在初始化方法之前添加@PostConstruct注解，在销毁方法之前添加@PreDestroy注解，这2个注解都是Java EE的注解，来自javax包下，所以，在使用之前，需要为当前项目添加Tomcat运行环境，代码部分例如： @Component(&quot;userDao&quot;) public class UserDao { public UserDao() { System.out.println(&quot;UserDao的构造方法被执行！&quot;); } @PostConstruct public void init() { System.out.println(&quot;UserDao.init()&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;UserDao.destroy()&quot;); } }注意：如果导入他人的项目，或者本机更换了Tomcat软件，都需要重新勾选项目属性中的Targeted Runtimes中的Tomcat。 2.4. 【重要】自动装配假设在UserDao中存在public void findUserByUsername()方法，然后，在UserService中声明了private UserDao userDao;属性，并且，存在public void login()方法，在方法内部，调用了userDao的findUserByUsername()方法： @Component(&quot;userDao&quot;) public class UserDao { public void findUserByUsername() { System.out.println(&quot;UserDao.findUserByUsername()&quot;); } } @Service public class UserService { private UserDao userDao; public void login() { System.out.println(&quot;UserService.login()&quot;); userDao.findUserByUsername(); } }在需要自动装配属性值的属性之前，添加@Autowired注解，就可以实现自动装配： @Autowired private UserDao userDao;注意：使用注解的自动装配不需要为属性添加SET方法！ 添加@Autowired实现自动装配，其装配方式是byType的，所以，在使用时，需要确保“其对应的值在Spring容器中应该是有且仅有1个的”！ 通过@Resource注解也可以实现自动装配！它是优先根据byName实现自动装配，在没有显式的指定bean-id的情况下，如果无法byName装配，则会尝试根据byType实现自动装配。 在实际使用时，可以自由选取以上2个注解中的任何一个！因为，在实际应用中，命名应该是规范的，并且，匹配类型的也应该是有且仅有1个。 以上2个注解中，@Autowired是Spring的环境中的注解类，而@Resource是Java EE环境中的注解类。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注入集合类型、注入properties类型、自动装配、Spring表达式]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%B3%A8%E5%85%A5%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B3%A8%E5%85%A5properties%E7%B1%BB%E5%9E%8B%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E3%80%81Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 【常用】通过SET方法注入属性的值（续）如果需要注入的属性的值并不是基本值（基本数据类型或String），则值需要配置为一个&lt;bean&gt;，且，注入值时，使用ref=&quot;bean-id&quot;来确定属性的值： ; 小结：为属性注入值时，如果类型是基本型，使用value进行配置，如果类型是引用，需要配置另一个bean来创建值的对象，然后通过ref进行配置。 2. 【不常用】通过构造方法注入属性的值首先，类中应该存在带参数的构造方法： public class User { public String name; public String from; public User(String name, String from) { super(); this.name = name; this.from = from; } }在配置时，通过&lt;constructor-arg&gt;配置构造方法的参数的值，如果有个参数，则需要多个节点，每个节点配置1个属性，且每个节点都必须添加index属性，表示配置的是第几个参数，取值为从0开始编号的数字，根据值的类型不同，继续配置value或ref来决定属性的值： &lt;bean id=&quot;user&quot; class=&quot;cn.tedu.spring.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;LiuGB&quot;&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;HeBei&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;3. 注入集合类型的值例如存在类： public class SampleBean { public List&lt;String&gt; names; public void setName(List&lt;String&gt; names) { this.names = names; } }然后，添加配置： &lt;bean id=&quot;sampleBean&quot; class=&quot;cn.tedu.spring.SampleBean&quot;&gt; &lt;property name=&quot;names&quot;&gt; &lt;list&gt; &lt;value&gt;Jame&lt;/value&gt; &lt;value&gt;Lucy&lt;/value&gt; &lt;value&gt;David&lt;/value&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;Alex&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;因为names属性的类型是List，所以，在注入值时，&lt;property&gt;节点中添加子级的&lt;list&gt;节点进行配置，在&lt;list&gt;中的每组&lt;value&gt;节点表示1个值。 如果属性是Set类型的，则使用&lt;set&gt;节点进行配置即可： &lt;property name=&quot;cities&quot;&gt; &lt;set&gt; &lt;value&gt;Hangzhou&lt;/value&gt; &lt;value&gt;Beijing&lt;/value&gt; &lt;value&gt;Shanghai&lt;/value&gt; &lt;value&gt;Shenzhen&lt;/value&gt; &lt;value&gt;Guangzhou&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 如果属性是Map类型的，则需要使用&lt;map&gt;及其子级的&lt;entry&gt;节点进行配置： &lt;property name=&quot;session&quot;&gt; &lt;map&gt; &lt;entry key=&quot;username&quot; value=&quot;Jack&quot;/&gt; &lt;entry key=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;entry key=&quot;from&quot; value=&quot;Nanjing&quot;/&gt; &lt;/map&gt; &lt;/property&gt;还有Properties类型，通常在使用时，会自定义一个???.properties文件，例如： url=jdbc:mysql://192.168.0.251:3306/db_name?useUnicode=true&amp;characterEncoding=utf8 driver=com.mysql.jdbc.Driver username=root password=root initialSize=2 maxActive=10然后，通过Spring框架读取该文件的信息： &lt;util:properties id=&quot;config&quot; location=&quot;classpath:db.properties&quot;&gt;&lt;/util:properties&gt;以上&lt;util:properties&gt;节点本质上也是一个&lt;bean&gt;，在注入值时： &lt;property name=&quot;dbConfig&quot; ref=&quot;config&quot;&gt; &lt;/property&gt;当然，Properties类型的节点是可以直接配置的，例如： &lt;property name=&quot;dbConfig&quot;&gt; &lt;props&gt; &lt;prop key=&quot;name&quot;&gt;Jack&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;事实上，关于List、Set、Map也存在&lt;util:list&gt;等类似节点，使用频率较低。 以上2种为Properties类型的数据注入值的做法都是有用的！而为List、Set、Map类型的数据注入值的应用场景相对较少。 4. 自动装配（Auto-wire）自动装配表示由Spring自动的为属性注入值，即：无需配置各&lt;property&gt;节点！可以解决需要注入多个值时添加多个&lt;property&gt;节点导致的配置项太多的问题！ 当需要自动装配时，为&lt;bean&gt;节点添加autowire属性的配置即可，常用的取值有byName和byType： 当取值为byName时 表示“根据名称实现自动装配”，即：当某个&lt;bean&gt;配置了autowire=&quot;byName&quot;时，Spring会检索当前类中的SET系列方法，根据SET方法的名称还原出属性名，并且尝试在Spring容器中找到bean-id相同的对象，如果找到，则自动为这些属性赋值，如果没有找到，也不会报告任何错误，只是相关属性没有被赋值而已！这种做法本质上还是通过SET方式注入的，所以，需要被注入的属性一定要有SET方法！而SET方法的名称一定与值对应的bean-id是匹配的！ 当取值为byType时 顾名思义，当取值为byType时，会“根据类型实现自动装配”，例如private IUserDao userDao;时，会尝试在Spring容器中查询类型符合IUserDao类型的&lt;bean&gt;，如果找到，则自动装配，否则，将跳过。 使用这种做法时，无需关心各个名称（属性名、方法名、bean-id），但是，需要保证“能匹配的bean只有1个”，否则，会出现NoUniqueBeanDefinitionException，并提示例如：expected single matching bean but found 2: userDao2,userDao。 小结 自动装配还有其它模式，暂不需要了解。 记住byName和byType的意义，及byType的注意事项。 自动装配虽然简单，但是，存在“是否注入值不明确”的问题，即：只能看到哪些&lt;bean&gt;配置了autowire=&quot;byName&quot;或autowire=&quot;byType&quot;，但是，这些类中的属性是否成功的注入了值、哪些属性是需要注入值的……等问题并不明确，也无从可查，所以，关于这种自动装配的做法是不推荐的！ 5. Spring表达式Spring表达式的基本格式是#{名称}，用于表示某个值，甚至，值可以是来自另一个&lt;bean&gt;的某个属性！ 当某个注入的属性值是通过Spring表达式得到的，则应该配置为value=#{}格式。 关于Spring表达式： 如果获取另一个&lt;bean&gt;中的某属性值，则使用#{bean-id.属性名}； 如果获取另一个&lt;bean&gt;中的某List集合中的某个值，则使用#{bean-id.List集合名[索引]}； 如果获取另一个&lt;bean&gt;中的某Map集合中的某个值，则使用#{bean-id.Map集合名.key}，还可以是#{bean-id.Map集合名[&#39;key&#39;]}。 1. 什么时候需要自定义构造方法？如果某个类没有显式的添加构造方法，则编译器会自动添加公有的、无参数的构造方法，例如： public class User { }等效于： public class User { public User() { super(); } }如果显式的添加了构造方法，则编译器就不会添加任何构造方法！ 通常，需要自定义构造方法的原因：不允许使用公有的、无参数的构造方法。 具体的表现： 限制创建对象，例如：单例模式； 强制要求得到某数据； 快速创建对象、确定某些属性的值。 2. List和Set的特性List：顺序的，先存入的数据在前，后存入的数据在后；元素可重复； Set：散列的，先存入的数据不一定在前，后存入的数据不一定在后；元素不可重复，如果尝试添加相同的数据，在Set中并不会不多项该元素，关于“是否相同”的评定依据是“2个数据的equals()对比结果为true，并且hashCode()的返回值必须相同”！ Set的本质是一个只关心key不关心value的Map！ Model：DAOView：html/jspController：Servlet View &gt; Controller &gt; Model（Service + DAO） Service：登录 Service：注册 DAO：根据用户名查询用户信息]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring简介、对象获取方式、对象生命周期、单例模式、SET注入]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%AE%80%E4%BB%8B%E3%80%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%E3%80%81%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%81SET%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1. 框架框架是一套已经编写好的程序结构，开发者在使用框架之后，可以在此基础之上进行开发，而不必关心偏底层的问题。 框架通常可以提高开发效率，一定程度上还解决了一些其它的问题，可能是性能的问题，或者数据安全的问题，或者程度的可维护性的问题等等。 框架具体的表现就是一系列的jar包，并且，可能改变原有的编程方式或流程。 普通的jar包，例如dom4j、mysql-connector等，只是实现了某个功能，相当于是一套工具。 2. 课程任务 Spring框架 SpringMVC框架 MyBatis框架 3. Spring框架3.1. 作用创建和管理对象。 传统的创建对象的方法是：Object obj = new Object(); 使用Spring框架后：Object obj = 框架.getXXX(); 即：开发者无需关注对象的创建过程，改由框架来创建，当需要对象时，通过框架获取即可。 传统的管理对象可能有：student.setName(&quot;张三同学&quot;); 使用Spring框架后，无需执行相关代码，通过配置，获取对象时，相关属性就已经有值了。 3.2. 项目准备先创建Maven项目，勾选Create a simple project，Group Id为cn.tedu.spring，Artifact Id为SPRING-01，Packaging选择war，创建好项目后，默认项目是出错的，需要生成web.xml文件。 使用Spring之前，需要添加相关依赖，artifactId为spring-webmvc，且groupId是org.springframework，版本通常选择3.2或以上版本，但，目前尚不推荐使用5.x版本。 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;以上代码，应该添加到项目的pom.xml的&lt;dependencies&gt;节点的内部。 然后，下载得到applicationContext.xml文件，复制到项目中的src\main\resources文件夹下： 3.3. 通过Spring获取对象–类中存在无参数构造方法（常用）在Spring的配置文件（applicationContext.xml）中，添加： &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;以上配置中，class表示“类”，取值应该是类的全名，即包名和类名，id是自定义的名称，通常使用类名并且首字母改为小写，例如类名是Date，则id值为date，如果类名是Student，则id值为student。 完成配置后，就可以在程序中，通过Spring根据date名称获取java.util.Date的对象，可以在src\main\java中创建可执行的Java类： package cn.tedu.spring; public class SpringTest { public static void main(String[] args) { } }然后，编写程序： public static void main(String[] args) { // 加载Spring的配置文件，获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 通过Spring容器获取对象 Date date = (Date) ac.getBean(&quot;date&quot;); // 测试输出 System.out.println(date); } 自定义User类，在Spring的配置文件中添加配置，最终，在程序中，获取User类的对象。 以上操作，要求类中存在无参数的构造方法，如果不具备条件，则： Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;user&apos; defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.tedu.spring.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;() Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.tedu.spring.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;() Caused by: java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;()这种做法对构造方法的访问权限并没有任何要求，即使是private权限，也不影响Spring创建对象！ 此次实现的代码中，关于ac变量，会提示警告：ac is never closed，即：推荐调用ac.close()以释放资源，但是，ApplicationContext接口中并没有声明close()方法，所以，应该将ac的类型声明为AbstractApplicationContext。 3.4. 通过Spring获取对象–类中存在静态工厂方法（不常用）工厂方法：调用后可以返回类的对象的方法，也可以理解为生产对象的方法。 以Calendar为例，它是一个抽象类，是不可以直接通过new 构造方法()此类语法创建对象的！但是，在这个类中，有static Calendar getInstance()方法，这个方法，就称之为Calendar类的静态工厂方法！ 在Spring的配置文件中，配置： &lt;bean id=&quot;calendar&quot; class=&quot;java.util.Calendar&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;以上配置中，factory-method属性的值是静态工厂方法的名称。 配置时，无论是类的全名，还是方法的名称，都必须是已知条件。 练习：自定义类HuaWeiPhone，通过静态工厂方法，获取该类的对象！ 关于类： package cn.tedu.spring; public class HuaWeiPhone { // 使得当前类不存在无参数的构造方法 public HuaWeiPhone(Object obj){ super(); } // 静态工厂方法 public static HuaWeiPhone create() { return new HuaWeiPhone(null); } }关于配置： &lt;bean id=&quot;huaWeiPhone&quot; class=&quot;cn.tedu.spring.HuaWeiPhone&quot; factory-method=&quot;create&quot;&gt;&lt;/bean&gt;3.5. 通过Spring获取对象–存在实例工厂方法（不常用）实例工厂方法：通过某个实例（对象）调用的方法，并且，这个方法可以返回某个类的对象，是生产对象的方法。 假设存在某类需要被获取对象，不满足前序的2种条件： public class Car { public Car(Object obj) { } }则需要另一个类中存在工厂方法，可以创建它的对象 public class CarFactory { public Car makeCar() { return new Car(null); } }在配置时： &lt;bean id=&quot;carFactory&quot; class=&quot;cn.tedu.spring.CarFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;car&quot; class=&quot;cn.tedu.spring.Car&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;makeCar&quot;&gt;&lt;/bean&gt;以上配置中，factory-bean的值是工厂类的&lt;bean&gt;节点的id属性值。 3.6. 通过Spring获取对象–小结通过Spring创建对象，然后从Spring容器中获取对象，需要： 类中存在无参数的构造方法； 类中存在静态的工厂方法； 存在实例工厂方法。 以上3种方式中，第2种和第3种的使用频率较低，原因是满足条件的类较少。 3.7. 由Spring管理的对象的作用域单例：单一的实例，即在同一时刻，某个类的对象是唯一的！ 由Spring所管理的对象，默认都是单例的，在配置时，通过scope属性可以配置是否单例，默认取值为singleton，当取值为prototype时，是非单例的！ &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;单例模式可以区分为：懒汉式、饿汉式。 默认情况下，由Spring管理的单例对象是饿汉式的，通过lazy-init属性可以调整，该属性的值是布尔类型。 &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt;3.8. 由Spring管理的对象的生命周期仅由Spring管理的、单例的对象存在生命周期问题！ 开发者可以在任何自定义的、由Spring管理的类中添加初始化方法和销毁方法，方法必须是void和无参数的，例如： public class Stduent { // 初始化方法 public void init() { System.out.println(&quot;Student.init()&quot;); } // 销毁方法 public void destroy() { System.out.println(&quot;Student.destroy()&quot;); } }然后，在Spring的配置文件中进行配置： &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;注意：对于非单例的对象而言，生命周期方法是没有意义的。 3.9. 通过SET方式注入属性的值基本概念：通过Spring的配置，确定某个类中的某个属性的值，使得最终获取对象时，属性是已经被赋值的。 假设存在UserDao类，在类中有String username和String password表示访问数据库的用户名和密码： public class UserDao { // 模拟：访问数据库的用户名 String username; // 模拟：访问数据库的密码 String password; }需要注入值的属性，必须有set方法，即设置它的值的方法，且方法名称必须以set作为前缀： public void setUsername(String u) { username = u; }然后，在Spring的配置文件中： &lt;bean id=&quot;userDao&quot; class=&quot;cn.tedu.spring.UserDao&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt;即：添加子级&lt;property&gt;节点，在该节点，配置name和value，其中，name表示属性，value表示值。 注意：在配置的name时，值应该是需要注入的属性的set方法名称中不包含set的部分，且首字母是小写的！ 其它1. 关于Maven中依赖出错在添加依赖后，下载到的jar包文件可能是已损坏的，或数据不完整的，可能表现为：下载的jar包的数量不正确，或者，编写代码时，某个类无法识别等…… 解决方案： 打开Eclipse的设置，找到Maven &gt; User Settings，面板中的Local Repository就是本地仓库文件夹； 关闭Eclipse，因为已经打开的项目可能引用了本地仓库文件夹中的某个jar包，如果Eclipse正在运行，可能导致后续的删除操作无法执行； 打开本地仓库文件夹，删除出错的jar包文件（通常jar包文件对于新生来说不易于查找，所以，简单的操作方式就是将整个本地仓库文件夹全部删除）； 打开Eclipse，找到需要开发的项目，点击右键，选择Maven &gt; Update Project，在弹出的对话框中，选中Force update ...选项，然后，开始更新即可。 2. Resource leakResource leak表示“内存溢出”（内存泄露）。 模拟情景：假设存在D:/a.txt，在程序中，通过FileInputStream fis访问该文件，在访问过程中，如果出现异常，导致程序结束，然后，JVM中垃圾回收机制尝试回收垃圾时，找到了fis，但是，前序fis并没有正常关闭，仍然连接着硬盘上的a.txt文件，在JVM看来，这个fis仍处于使用状态，不是垃圾！但是，以程序员的角度来看，fis是一个变量，当程序崩溃时，这个变量就已经无法继续使用，就是个垃圾！所以，就会出现“已经无法继续使用的对象，却不会被视为垃圾数据，无法被回收！” 如果以上类似的垃圾数据越来越多，就会导致可用内存越来越少，当达到极端状态时，就会出现“内存溢出”！ 所以，其实，少量的内存溢出，并没有明显的危害！但是，作为开发者，应该尽量的避免任何可能出现的内存溢出！ 解决内存溢出的核心：尽早释放不再使用的资源，例如流、数据库访问的相关对象、XML的读写工具等连接型资源，对于可能抛出异常的代码，应该添加finally代码块，并在其中释放资源。 3. 单例模式示例public class King { private static King king; private King() { } public static King getKing() { if (king == null) { king = new King(); } return king; } }以上是懒汉式单例模式的代码，且，没有解释线程安全问题。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F03%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1.http协议 (了解)(1)什么是http协议?是一种网络应用层协议、规定了浏览器与web服务器之间如何通信以及相应的数据包的格式。 1)如何通信?step1.建立连接 step2.发送请求 step3.发送响应 step4.关闭连接 这样做的好处是，服务器可以利用有限的连接数为尽可能 多的请求服务。 2)数据包的格式a.请求数据包 请求行(请求方式 请求资源路径 协议和版本) 若干消息头 消息头是一些键值对，使用&quot;: &quot;隔开，通信的 双方可以借助于消息头来传递一些特定的信息，比如 浏览器可以发送&quot;user-agent&quot;消息头，告诉服务器 浏览器的类型和版本。 实体内容 如果请求类型为get，实体内容为空。 只有当请求类型为post时，实体内容才会有数据。b.响应数据包 状态行(协议类型和版本 状态码 状态描述) 注： 状态码是一个三位数字，表示服务器处理请求 的一种状态，常见状态码如下: 200: 正常 500: 系统出错 404: 请求路径出错 若干消息头 服务器也可以发送一些消息头给浏览器，比如，发送 content-type消息头，告诉浏览器，服务器返回的数据类型（包括编码）c.实体内容 程序的处理结果，浏览器会解析出来，生成相应的页面。(2)两种请求方式1)哪些情况下，浏览器会发送get请求?a.直接在浏览器地址栏输入地址。 b.点击链接。 c.表单的默认提交方式。2)get请求的特点a.会将请求参数显示在浏览器地址栏，不安全。 注： 因为有些网络设备(比如路由器)会记录访问地址。 b.会将请求参数添加到请求资源路径的后面，只能提交 少量的数据给服务器。 注： 因为请求行大约只能存放2k左右的数据。3)哪些情况下，浏览器会发送post请求a.设置表单的method属性值为&quot;post&quot;。 4)post请求的特点a.不会将请求参数显示在浏览器地址栏，相对安全。 注： http协议并不会对数据进行加密，所以，对于 敏感数据，需要进行加密处理(使用https协议)。 b.将请求参数添加到了实体内容里面，可以提交大量的 数据给服务器。2.Servlet输出中文需要注意的问题(1)为什么会产生乱码?因为out.println方法默认会使用”iso-8859-1”来编码。 (2)如何解决?response.setContentType(“text/html;charset=utf-8”); 3.读取请求参数值(1)String getParameter(String paramName)a.请求参数名(paramName)要与实际传递过来的请求 参数名一致，否则会获得null值。 b.提交表单时，如果不填写任何数据，会获得&quot;&quot;。(2)String[] getParamterValues(String paramName)a.当有多个请求参数名相同时，使用此方法。 b.对于多选框，如果不选择任何选项，会获得null值。4.表单包含有中文参数值，如何处理?(1)为什么会产生乱码?提交表单时，浏览器会对表单中的中文参数值进行编码，比如使用utf-8来编码，服务器端默认会使用iso-8859-1来解码，所以会产生乱码。 注： 浏览器会按照打开该表单所在页面时的字符集来编码。(2)如何解决?1)post请求request.setCharacterEncoding(“utf-8”); 注： 此行代码要添加到所有的getParameter方法的最前面。 只针对post请求有效。2)get请求修改tomcat的配置文件(server.xml) &lt;Connector URIEncoding=&quot;utf-8&quot;/&gt; 注： 只针对get请求有效。5.访问数据库step1.导包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;step2.添加jdbc.properties文件。 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/jsd1807db?useUnicode=true&amp;characterEncoding=UTF-8 username=root password=rootstep3.添加DBUtils类。 public class DBUtils { private static String driver; private static String url; private static String username; private static String password; private static BasicDataSource dataSource; static { Properties prop = new Properties(); InputStream ips = DBUtils.class .getClassLoader() .getResourceAsStream(&quot;jdbc.properties&quot;); try { prop.load(ips); driver = prop.getProperty(&quot;driver&quot;); url = prop.getProperty(&quot;url&quot;); username = prop.getProperty(&quot;username&quot;); password = prop.getProperty(&quot;password&quot;); //创建数据源对象 dataSource = new BasicDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(3); dataSource.setMaxActive(3); } catch (IOException e) { e.printStackTrace(); }finally { try { ips.close(); } catch (IOException e) { e.printStackTrace(); } } } public static Connection getConn() throws Exception { return dataSource.getConnection(); } public static void close(Connection conn, Statement stat, ResultSet rs) { try { if(rs!=null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if(stat!=null) { stat.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if(conn!=null) { //打开自动提交 conn.setAutoCommit(true); conn.close(); } } catch (SQLException e) { e.printStackTrace(); } } }step4.添加一张表(t_user) create table t_user( id int primary key auto_increment, username varchar(50) unique, password varchar(20), email varchar(30) );step5.在service方法里面，使用jdbc api访问数据库 public class AddUserServlet extends HttpServlet{ @Override protected void service( HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //处理表单中文参数值的问题 request.setCharacterEncoding(&quot;utf-8&quot;); /* * 这行代码的作用: * 1.设置content-type消息头的值。 * 2.out.println方法在输出时，会使用 * charset指定的字符集来编码。 */ response.setContentType( &quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); //读取用户信息 String username = request.getParameter(&quot;username&quot;); String pwd = request.getParameter(&quot;pwd&quot;); String email = request.getParameter(&quot;email&quot;); //将用户信息插入到数据库 Connection conn = null; PreparedStatement ps = null; try { conn = DBUtils.getConn(); String sql = &quot;INSERT INTO t_user &quot; + &quot;VALUES(null,?,?,?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, username); ps.setString(2, pwd); ps.setString(3, email); ps.executeUpdate(); out.println(&quot;添加成功&quot;); } catch (Exception e) { /* * step1.记日志(保留现场) * 注： * 在实际项目中，经常需要将异常 * 信息写到文件里面。 */ e.printStackTrace(); /* * step2.看异常能否恢复，如果 * 异常不能够恢复(比如数据库服务 * 停止、网络中断等等，这样的异常 * 我们一般称之为系统异常)，则提示 * 用户稍后重试； * 如果能够恢复，则立即恢复。 */ out.println(&quot;系统繁忙，稍后重试&quot;); }finally { DBUtils.close(conn, ps, null); } } }]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet简介、Servlet开发步骤、Servlet运行流程、常见问题及解决方式]]></title>
    <url>%2F2019%2F06%2F03%2FServlet%E7%AE%80%E4%BB%8B%E3%80%81Servlet%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E3%80%81Servlet%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.什么是Servlet?sun公司制订的一种用来扩展web服务器功能的组件规范。 (1)扩展web服务器功能web服务器只能够处理静态资源的请求（即需要事先将 静态页面写好），不能够处理动态资源的请求（即需要进行计算，生成动态页面），所以，需要扩展其功能。 可以使用Servlet来扩展web服务器功能，web服务器收到 请求之后，如果需要计算，则调用Servlet来处理。(2)组件规范1)什么是组件?符合规范、实现部分功能，并且需要部署到相应的容器当中才能运行的软件模块。 Servlet是一个组件，必须符合Servlet规范，并且需要部署到Servlet容器当中才能运行。2)什么是容器?符合规范、提供组件运行环境的程序。 Servlet容器(比如Tomcat)为Servlet提供运行环境 (主要是提供网络相关的服务)2.如何写一个Servlet?step1.写一个java类，实现Servlet接口或者继承HttpServlet。 step2.编译。 step3.打包。（即建立一个具有如下结构的文件夹） appname WEB-INF classes (放.class文件) lib (可选，放.jar文件) web.xml (部署描述文件)step4.部署。 把step3创建好的文件夹拷贝到容器指定的位置。 注： 可以将step3创建好的文件夹压缩成&quot;.war&quot;为后缀 的文件，然后拷贝。step5.启动容器，访问Servlet。 http://ip:port/appname/url-pattern 注: url-pattern在web.xml中设置。3.Servlet是如何运行的?比如，在浏览器地址栏输入http://localhost:8080/day01/hello step1.浏览器依据ip和port建立连接。 step2.浏览器将相关数据放到请求数据包，然后将请求 数据包发送给服务器。 step3.服务器解析请求数据包，将解析到的结果放到 request对象里面，同时，创建一个response对象。 step4.服务器依据请求路径，创建Servlet对象，然后 调用该对象的service方法。 注: 开发人员只需要调用request对象的方法，就 可以获得请求数据包中的数据。类似的，只需要调用 response对象的方法，就可以将处理结果写到 response对象里面，容器会从response对象中取 出处理结果，然后创建响应数据包并发送给浏览器。 step5.容器从response对象中取出处理结果，然后创建 响应数据包并发送给浏览器。 step6.浏览器解析响应数据包，生成结果页面。4.常见错误(1)404a.含义：服务器依据请求路径，找不到对应的资源。 b.错误原因: b1.请求路径写错。 b2.应用没有部署或者部署失败。(2)500a.含义:服务器端程序运行发生问题。 b.错误原因: b1.没有严格按照规范来写代码。 比如，没有继承HttpServlet或者实现Servlet 接口。又或者部署描述文件写错。 b2.代码写得不严谨。 比如，对请求参数值没有做任何检查就直接做类型 转换。(3)405a.含义:服务器找不到处理方法。 b.错误原因: 没有正确override HttpServlet的service方法。练习：写一个Servlet(比如DateServlet)，输出当前的系统日期，比如”2018-10-25” ## 提示 step1.创建一个maven工程。注意三个细节:细节1:选war包，如下图所示: 细节2:工程建完之后，默认没有带web.xml文件，需要添加web.xml文件,如下图所示: 细节3:指定servlet容器，如下图所示: step2.添加一个java类(DateServlet)参考代码如下: public class DateServlet extends HttpServlet{ public void service( HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException{ //生成日期信息 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateInfo = sdf.format(date); //输出日期 response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(dateInfo); out.close(); } }step3. 在web.xml添加该Servlet的配置参考配置如下: &lt;servlet&gt; &lt;servlet-name&gt;dateServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;web.DateServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dateServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/date&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;step4.部署、运行 Tomcat的配置请参考doc.tedu.cn上的文档。 练习写一个Servlet,计算一个人的BMI指数。 BMI指数 = 体重(公斤) / 身高(米) / 身高(米)]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库介绍 SQL基础]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D-SQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库之前通过流去操作文件保存数据的弊端： 执行效率低 开发成本高 一般只能保存小量数据 只能保存文本数据 什么是DB DataBase 数据库： 代表文件集合什么是DBMS DataBaseManagementSystem 数据库管理系统(软件) ，用于管理保存数据的文件集合，用于和程序员进行交互，常见的DBMS有：Oracle MySQL DB2 SQLServer Sqlite ，DBMS具备网络访问能力 SQL Structured Query Language：结构化查询语言，用户程序员和DBMS进行交互，用于程序员告诉DBMS到底对数据进行什么操作的 数据库的分类（了解） 关系型数据库：经过数学理论验证可以将现实生活中的各种关系保存到数据库，这种就称为关系型数据库。保存数据以表为单位 非关系数据库：一般都是为了解决某些特定场景的问题比如：缓存，高并发访问，Redis数据库（以key-value形式保存数据）常见的关系型数据 MySQL: 属于Oracle公司的产品，08被Sun公司收购，09年Sun公司被Oracle收购，开源免费，被收购后发布5.5版本使用Oracle的部分技术，性能提高了30%以上，用户量增多，计划把MySQL闭源 原MySQL程序员离开Oracle创建了MariaDB 老板女儿Maria。市场排名第一 Oracle: 排名第二，闭源 性能最高 收费最贵 DB2： IBM公司产品 闭源项目 SQLServer：微软公司产品 闭源 Sqlite：轻量级数据库，安装包几十k，应用在嵌入式设备或移动设备上， 开源和闭源 开源：开放源代码 免费试用，通过卖服务盈利，社会上会有一些大牛程序员会无偿的维护和升级 闭源：不开放源代码 收费，通过卖产品+服务盈利 ，有大牛会攻击破坏，但是人家养了一群人维护升级 打开客户端连接MySQL 在终端中执行： mysql -uroot -p 回车 如果有密码写密码 回车 如果没有密码则直接回车 和数据库相关的SQL查询所有数据库 show databases;创建数据库 create database db1;查看数据库详情 show create database db1;创建数据库指定字符集 create database db2 character set gbk/utf8;删除数据库 drop database db2;使用数据库 use db1;和表相关的SQL查询所有表 show tables;创建表 create table 表名(字段1名 字段1的类型,字段2名 字段2的类型,…..); create table person(name varchar(10),age int); 创建一个学生表（student） 保存学号id,姓名name,年龄age,语文chinese,数学math,英语english create table student(id int,name varchar(10),age int,chinese int,math int,english int);查看表详情 show create table 表名; show create table person;创建表时指定表的引擎和字符集 create table t1(name varchar(10)) engine=myisam charset=gbk; 表的引擎 innodb：支持数据库的高级操作如：外键、事务等，默认引擎 myisam：只支持基础的增删改查操作 SQL格式： 可以有换行 最后以;结尾 关键字之间需要有空格(可以写多个空格，建议写一个) 查看表字段 desc 表名;删除表 drop table 表名;修改表相关修改表名——rename table 原名 to 新名; rename table student to stu;修改表的引擎和字符集——alter table 表名 engine=myisam/innodb charset=utf8/gbk; alter table stu engine=myisam charset=gbk;添加表字段最后面： alter table 表名 add 字段名 字段类型;最前面： alter table 表名 add 字段名 字段类型 first;xxx的后面: alter table 表名 add 字段名 字段类型 after xxx; create table hero(name varchar(10)); alter table hero add age int; alter table hero add id int first; alter table hero add sal int after name;删除表字段——alter table 表名 drop 字段名; alter table hero drop sal;修改表字段的名字和类型——alter table 表名 change 原字段名 新字段名 新字段类型; alter table hero change name heroname varchar(5);修改表字段的类型和位置——alter table 表名 modify 字段名 类型 位置; alter table hero modify age int first(after xxx); 练习： 创建数据库newdb并使用， 里面创建员工表t_emp只有name字段 引擎为myisam 字符集为gbk 1). create database newdb; 2). use newdb; 3). create table t_emp(name varchar(10)) engine=myisam charset=gbk; 修改表名为emp 1). rename table t_emp to emp; 修改引擎为innodb 字符集为utf8 1). alter table emp engine=innodb charset=utf8; 添加部门编号字段deptno 在最后面 1). alter table emp add deptno int; 添加员工编号 empno在最前面 1). alter table emp add empno int first; 添加salary字段在name的后面 1). alter table emp add salary int after name; 修改salary字段名字为sal，把sal放在empno的后面 1). alter table emp change salary sal int; 2). alter table emp modify sal int after empno; 删除sal字段 1).alter table emp drop sal; 删除表 1).drop table emp; 删除数据库1).drop database newdb; 数据相关插入数据create table emp(id int,name varchar(10),age int,sal int); 全表插入数据： insert into emp values(1,’Tom’,18,3000); 指定字段插入数据： insert into emp (name,age) values(‘Jerry’,19); insert into emp (name) values(‘李白’); 批量插入数据： insert into emp values(3,’刘备’,28,6000),(4,’张飞’,20,5000),(5,’关羽’,25,9000); insert into emp (name,age) values(‘悟空’,500),(‘八戒’,400),(‘沙僧’,200);查询数据 查询全部数据的全部字段信息 select * from emp; 查询所有员工的姓名和年龄 select name,age from emp; 查询年龄在25岁以下的员工信息 select * from emp where age&lt;25; 查询工资3000块钱的员工姓名、年龄、工资 select name,age,sal from emp where sal=3000;修改数据 修改Tom的工资为3333 update emp set sal=3333 where name=’Tom’; 修改30岁以下的工资为666 update emp set sal=666 where age&lt;30; 修改id等于3的名字为吕布 年龄为55 工资为20000 update emp set name=’吕布’, age=55, sal=20000 where id=3; 修改工资为null的工资为800 update emp set sal=800 where sal is null;删除数据 删除id=1的员工 delete from emp where id=1; 删除年龄在25岁以下的员工 delete from emp where age&lt;25; 删除全部数据 delete from emp; insert into t1 (字段名1,字段名2) values(值1,值2),(值1,值2);select name,age from t1 where id&lt;5;update t1 set 字段名=值, 字段名=值 where id=5;delete from t1 where id&lt;3; 练习： 创建hero表如果存在则先删除再创建， id 姓名name 类型type 金币money 插入以下数据 1 诸葛亮 法师 18888 ， 2 孙悟空 打野 18888 ，3 小乔 法师 6888，4 黄忠 射手 8888， 5 刘备 战士 6888 修改所有18888的为28888 修改所有打野为刺客 删除价格为6888的英雄 修改孙悟空为猪八戒 删除id为1，2，3的英雄 修改所有英雄的类型为已阵亡 删除所有数据 删除表 中文字符问题 set names gbk;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主键约束、拆分表、事务、数据类型]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E3%80%81%E6%8B%86%E5%88%86%E8%A1%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主键约束 primary key主键：用于表示数据唯一性的字段称为主键约束： 是给表字段添加的限制条件主键约束：限制主键字段值不能重复并且非空 (唯一且非空)create table t1(id int primary key,name varchar(10)); insert into t1 values(1,&apos;Tom&apos;); insert into t1 values(1,&apos;Jerry&apos;);//失败 重复 insert into t1 values(null,&apos;ABC&apos;);//失败 不能为null 自增： auto_incrementcreate table t2(id int primary key auto_increment,name varchar(10)); insert into t2 values(null,&apos;AAA&apos;); insert into t2 values(2,&apos;AAA&apos;); insert into t2 values(10,&apos;mm&apos;); insert into t2 values(null,&apos;AAA&apos;); 1. 当字段值为null的时候值会自己增长 2. 自增字段值也可以手动赋值 3. 增长规则：从曾经出现的最大值基础上+1 4. 自增数值只增不减 (delete清空表 自增数值并不清零)注释 comment创建表声明字段的时候给字段添加的介绍create table t3(id int primary key auto_increment comment &apos;这是一个主键&apos;,name varchar(10) comment &apos;这是员工的姓名&apos;);` 和 ‘`: 用于修饰表名和字段名 可以省略create table `t4`(`id` int,`name` varchar(10));‘ :用于修饰字符串数据冗余如果表设计不够合理，保存大量数据的同时可能随之会出现大量重复数据，这些重复数据的现象就称为数据冗余，通过拆分表的形式解决冗余问题 练习：设计表保存以下数据：设计表保存以下数据： 保存男装分类(category)下西服分类下的商品皮尔卡丹西服，价格9800，库存98件 保存家用电器分类下，电视机分类下的小米电视，价格2500，库存108件 创建商品表 create table item(id int primary key auto_increment, name varchar(10),price int,num int,categoryid int); 创建分类表 create table category(id int primary key auto_increment,name varchar(10),parentid int); 插入数据 insert into category values(null,’男装’,null),(null,’西服’,1),(null,’家电’,null),(null,’电视机’,3); insert into item values(null,’皮尔卡丹’,9800,98,2),(null,’小米电视’,2500,108,4); 事务什么是事务？事务是数据库中执行SQL语句的最小工作单元，可以保证事务内的多条SQL语句要么全部成功，要么全部失败。 查看数据库自动提交的状态 show variables like ‘%autocommit%’; 关掉自动提交 0关闭 1开启 set autocommit=0; 测试转账： create table person(id int, name varchar(10),money int); insert into person values(1,’超人’,500),(2,’钢铁侠’,10000); 关掉自动提交： set autocommit=0; 先让超人+2000 update person set money=2500 where id=1; 开启另一个终端 验证 此时数据库文件中的数据并没改掉 让钢铁侠-2000 update person set money=8000 where id=2; 执行提交 commit; 回滚 rollback;将内存中的修改回滚到上次提交（commit）的点update person set money=100 where id=1; rollback;保存回滚点 savepointupdate person set money=100 where id=1; savepoint s1; update person set money=200 where id=1; savepoint s2; rollback to s1; SQL的分类DDL Data Definition Language 数据定义语言，包括 create,alter,drop,truncate ,不支持事务DML Data Manipulation Language 数据操作语言， 包括 insert,delete,update,select(DQL),支持事务DQL Data Query Language 数据查询语言，只包括select，和事务没有关系因为并没有修改数据TCL Transaction Control Language 事务控制语言，包括 commit,rollback, savepoint,rollback toDCL Data Control Language 数据控制语言，用于处理分配用户权限相关的操作 truncate truncate table 表名; 删除表并且创建一个新表 truncate、drop和delete的区别： delete用于删除数据，使用delete清空表时自增数值不清零 执行效率最低 drop 用于删除表 执行效率最高 truncate 用于删除表并创建新的空表，执行效率比delete要高，而且自增数值会清零 数据库的数据类型整数 常用整数有 int(m)和bigint(m)，m代表显示长度必须和zerofill结合使用 create table t_int(num int(10) zerofill); insert into t_int values(123); select * from t_int; 浮点数 常用浮点数double(m,d) m代表总长度 d代表小数长度 23.346 m=5 d=3 decimal超高精度浮点数，应用场景：涉及超高精度运算时使用 create table t_double(num double(5,3)); insert into t_double values(23.5678); 值为23.568 insert into t_double values(23.5); 值为23.500 字符串 char(m): 固定长度 m=10 abc 占10，效率高，最大255 varchar(m):可变长度 m=10 abc 占3，节省空间，最大65535，如果超过255建议使用text text(m):可变长度 最大65535日期 date:只能保存年月日 time:只能保存时分秒 datetime:保存年月日时分秒，默认值为null，最大值9999-12-31 timestamp(时间戳距离19700101 08：00：00):保存年月日时分秒，默认值为当前系统时间,最大值2038-01-19 create table t_time(t1 date,t2 time,t3 datetime,t4 timestamp); insert into t_time values(‘2018-10-16’,null,null,null); insert into t_time values (null,’20:06:32’,’2008-11-22 18:22:11’,null); 配置URL：jdbc:mysql://localhost:3306/db2?useUnicode=true&amp;characterEncoding=UTF-8 三方SQL工具：sqlyog]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
