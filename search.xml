<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring组件扫描、注解]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%E3%80%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 前2天小结 【理解】通过Spring获取对象的3种条件：无参构造方法、静态工厂方法、实例方法； 【理解】由Spring管理的对象的作用域及生命周期：单例、懒加载、生命周期方法； 【重要】通过SET方式注入属性的值，理解value和ref的使用； 【了解】通过构造方法注入属性的值； 【了解】注入集合类型的属性的值，包括：List / Set / Map； 【重要】注入Properties类型的属性的值，读取*.properties文件； 【理解】自动装配的作用，取值为byName与byType的特性； 【重要】Spring表达式 2. Spring注解（Annotation）2.1. 基本概念例如@Override就是注解，在Spring中定义了一些注解，可以取代在Spring的XML文件中的配置！ 2.2. 通过Spring获取对象案例目标：创建cn.tedu.spring.dao.UserDao类，然后，创建cn.tedu.spring.test.SpringTest类，通过Spring获取UserDao的对象。 在Spring中，有几种通用注解： @Component @Controller @Service @Repository 这些注解是添加在类的声明之前的，表示这个类是一个“组件”，是希望由Spring进行管理的！ 以上4个注解中，@Component表示“通用组件类”，@Controller表示“控制器类”，@Service表示“业务类”，@Repository表示“数据访问类/持久层处理的类”，这4个注解只有语义的区别，从功能和用法上来说，是完全一样的！即，如果愿意的话，可以用@Service注解添加在控制器类的声明之前，但是，不推荐这样做。 仅仅只是添加注解是不够的，还需要在Spring的配置文件中开启组件扫描： &lt;context:component-scan base-package=&quot;cn.tedu.spring.dao&quot; /&gt;以上配置中，base-package表示根包，即当配置为cn.tedu.spring时，其子级包例如cn.tedu.spring.dao或cn.tedu.spring.service等都在扫描范围之内！ 如果没有显式的指定bean-id，默认为使用类名且首字母改为小写，例如UserDao类的bean-id就是userDao。 以上注解都可以添加配置，例如@Service(&quot;bean-id&quot;)。 小结：通用注解共4个，其功能、用法都是完全相同的，只是表达的语义不同，添加的注解的类，并且在组件扫描范围之内，就会被Spring所管理，在配置组件扫描时，配置的包是“根包”，其范围不宜过大，在添加注解时，还可以自定义bean-id。 2.3. 作用域与生命周期由Spring管理的对象，默认是饿汉式的单例的，通过在类的声明之前添加注解@Lazy可以调整： @Component(&quot;userDao&quot;) @Lazy(true) public class UserDao { }还可以通过@Scope(&quot;singleton&quot;)或@Scope(&quot;prototype&quot;)注解调整是否为单例的： @Service @Scope(&quot;prototype&quot;) public class UserService { }关于生命周期方法，依然是先自定义生命周期方法，在初始化方法之前添加@PostConstruct注解，在销毁方法之前添加@PreDestroy注解，这2个注解都是Java EE的注解，来自javax包下，所以，在使用之前，需要为当前项目添加Tomcat运行环境，代码部分例如： @Component(&quot;userDao&quot;) public class UserDao { public UserDao() { System.out.println(&quot;UserDao的构造方法被执行！&quot;); } @PostConstruct public void init() { System.out.println(&quot;UserDao.init()&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;UserDao.destroy()&quot;); } }注意：如果导入他人的项目，或者本机更换了Tomcat软件，都需要重新勾选项目属性中的Targeted Runtimes中的Tomcat。 2.4. 【重要】自动装配假设在UserDao中存在public void findUserByUsername()方法，然后，在UserService中声明了private UserDao userDao;属性，并且，存在public void login()方法，在方法内部，调用了userDao的findUserByUsername()方法： @Component(&quot;userDao&quot;) public class UserDao { public void findUserByUsername() { System.out.println(&quot;UserDao.findUserByUsername()&quot;); } } @Service public class UserService { private UserDao userDao; public void login() { System.out.println(&quot;UserService.login()&quot;); userDao.findUserByUsername(); } }在需要自动装配属性值的属性之前，添加@Autowired注解，就可以实现自动装配： @Autowired private UserDao userDao;注意：使用注解的自动装配不需要为属性添加SET方法！ 添加@Autowired实现自动装配，其装配方式是byType的，所以，在使用时，需要确保“其对应的值在Spring容器中应该是有且仅有1个的”！ 通过@Resource注解也可以实现自动装配！它是优先根据byName实现自动装配，在没有显式的指定bean-id的情况下，如果无法byName装配，则会尝试根据byType实现自动装配。 在实际使用时，可以自由选取以上2个注解中的任何一个！因为，在实际应用中，命名应该是规范的，并且，匹配类型的也应该是有且仅有1个。 以上2个注解中，@Autowired是Spring的环境中的注解类，而@Resource是Java EE环境中的注解类。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注入集合类型、注入properties类型、自动装配、Spring表达式]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%B3%A8%E5%85%A5%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B3%A8%E5%85%A5properties%E7%B1%BB%E5%9E%8B%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E3%80%81Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 【常用】通过SET方法注入属性的值（续）如果需要注入的属性的值并不是基本值（基本数据类型或String），则值需要配置为一个&lt;bean&gt;，且，注入值时，使用ref=&quot;bean-id&quot;来确定属性的值： ; 小结：为属性注入值时，如果类型是基本型，使用value进行配置，如果类型是引用，需要配置另一个bean来创建值的对象，然后通过ref进行配置。 2. 【不常用】通过构造方法注入属性的值首先，类中应该存在带参数的构造方法： public class User { public String name; public String from; public User(String name, String from) { super(); this.name = name; this.from = from; } }在配置时，通过&lt;constructor-arg&gt;配置构造方法的参数的值，如果有个参数，则需要多个节点，每个节点配置1个属性，且每个节点都必须添加index属性，表示配置的是第几个参数，取值为从0开始编号的数字，根据值的类型不同，继续配置value或ref来决定属性的值： &lt;bean id=&quot;user&quot; class=&quot;cn.tedu.spring.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;LiuGB&quot;&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;HeBei&quot;&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;3. 注入集合类型的值例如存在类： public class SampleBean { public List&lt;String&gt; names; public void setName(List&lt;String&gt; names) { this.names = names; } }然后，添加配置： &lt;bean id=&quot;sampleBean&quot; class=&quot;cn.tedu.spring.SampleBean&quot;&gt; &lt;property name=&quot;names&quot;&gt; &lt;list&gt; &lt;value&gt;Jame&lt;/value&gt; &lt;value&gt;Lucy&lt;/value&gt; &lt;value&gt;David&lt;/value&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;Alex&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;因为names属性的类型是List，所以，在注入值时，&lt;property&gt;节点中添加子级的&lt;list&gt;节点进行配置，在&lt;list&gt;中的每组&lt;value&gt;节点表示1个值。 如果属性是Set类型的，则使用&lt;set&gt;节点进行配置即可： &lt;property name=&quot;cities&quot;&gt; &lt;set&gt; &lt;value&gt;Hangzhou&lt;/value&gt; &lt;value&gt;Beijing&lt;/value&gt; &lt;value&gt;Shanghai&lt;/value&gt; &lt;value&gt;Shenzhen&lt;/value&gt; &lt;value&gt;Guangzhou&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 如果属性是Map类型的，则需要使用&lt;map&gt;及其子级的&lt;entry&gt;节点进行配置： &lt;property name=&quot;session&quot;&gt; &lt;map&gt; &lt;entry key=&quot;username&quot; value=&quot;Jack&quot;/&gt; &lt;entry key=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;entry key=&quot;from&quot; value=&quot;Nanjing&quot;/&gt; &lt;/map&gt; &lt;/property&gt;还有Properties类型，通常在使用时，会自定义一个???.properties文件，例如： url=jdbc:mysql://192.168.0.251:3306/db_name?useUnicode=true&amp;characterEncoding=utf8 driver=com.mysql.jdbc.Driver username=root password=root initialSize=2 maxActive=10然后，通过Spring框架读取该文件的信息： &lt;util:properties id=&quot;config&quot; location=&quot;classpath:db.properties&quot;&gt; &lt;/util:properties&gt;以上&lt;util:properties&gt;节点本质上也是一个&lt;bean&gt;，在注入值时： &lt;property name=&quot;dbConfig&quot; ref=&quot;config&quot;&gt; &lt;/property&gt;当然，Properties类型的节点是可以直接配置的，例如： &lt;property name=&quot;dbConfig&quot;&gt; &lt;props&gt; &lt;prop key=&quot;name&quot;&gt;Jack&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;事实上，关于List、Set、Map也存在&lt;util:list&gt;等类似节点，使用频率较低。 以上2种为Properties类型的数据注入值的做法都是有用的！而为List、Set、Map类型的数据注入值的应用场景相对较少。 4. 自动装配（Auto-wire）自动装配表示由Spring自动的为属性注入值，即：无需配置各&lt;property&gt;节点！可以解决需要注入多个值时添加多个&lt;property&gt;节点导致的配置项太多的问题！ 当需要自动装配时，为&lt;bean&gt;节点添加autowire属性的配置即可，常用的取值有byName和byType： 当取值为byName时 表示“根据名称实现自动装配”，即：当某个&lt;bean&gt;配置了autowire=&quot;byName&quot;时，Spring会检索当前类中的SET系列方法，根据SET方法的名称还原出属性名，并且尝试在Spring容器中找到bean-id相同的对象，如果找到，则自动为这些属性赋值，如果没有找到，也不会报告任何错误，只是相关属性没有被赋值而已！这种做法本质上还是通过SET方式注入的，所以，需要被注入的属性一定要有SET方法！而SET方法的名称一定与值对应的bean-id是匹配的！ 当取值为byType时 顾名思义，当取值为byType时，会“根据类型实现自动装配”，例如private IUserDao userDao;时，会尝试在Spring容器中查询类型符合IUserDao类型的&lt;bean&gt;，如果找到，则自动装配，否则，将跳过。 使用这种做法时，无需关心各个名称（属性名、方法名、bean-id），但是，需要保证“能匹配的bean只有1个”，否则，会出现NoUniqueBeanDefinitionException，并提示例如：expected single matching bean but found 2: userDao2,userDao。 小结 自动装配还有其它模式，暂不需要了解。 记住byName和byType的意义，及byType的注意事项。 自动装配虽然简单，但是，存在“是否注入值不明确”的问题，即：只能看到哪些&lt;bean&gt;配置了autowire=&quot;byName&quot;或autowire=&quot;byType&quot;，但是，这些类中的属性是否成功的注入了值、哪些属性是需要注入值的……等问题并不明确，也无从可查，所以，关于这种自动装配的做法是不推荐的！ 5. Spring表达式Spring表达式的基本格式是#{名称}，用于表示某个值，甚至，值可以是来自另一个&lt;bean&gt;的某个属性！ 当某个注入的属性值是通过Spring表达式得到的，则应该配置为value=#{}格式。 关于Spring表达式： 如果获取另一个&lt;bean&gt;中的某属性值，则使用#{bean-id.属性名}； 如果获取另一个&lt;bean&gt;中的某List集合中的某个值，则使用#{bean-id.List集合名[索引]}； 如果获取另一个&lt;bean&gt;中的某Map集合中的某个值，则使用#{bean-id.Map集合名.key}，还可以是#{bean-id.Map集合名[&#39;key&#39;]}。 1. 什么时候需要自定义构造方法？如果某个类没有显式的添加构造方法，则编译器会自动添加公有的、无参数的构造方法，例如： public class User { }等效于： public class User { public User() { super(); } }如果显式的添加了构造方法，则编译器就不会添加任何构造方法！ 通常，需要自定义构造方法的原因：不允许使用公有的、无参数的构造方法。 具体的表现： 限制创建对象，例如：单例模式； 强制要求得到某数据； 快速创建对象、确定某些属性的值。 2. List和Set的特性List：顺序的，先存入的数据在前，后存入的数据在后；元素可重复； Set：散列的，先存入的数据不一定在前，后存入的数据不一定在后；元素不可重复，如果尝试添加相同的数据，在Set中并不会不多项该元素，关于“是否相同”的评定依据是“2个数据的equals()对比结果为true，并且hashCode()的返回值必须相同”！ Set的本质是一个只关心key不关心value的Map！ Model：DAOView：html/jspController：Servlet View &gt; Controller &gt; Model（Service + DAO） Service：登录 Service：注册 DAO：根据用户名查询用户信息]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring简介、对象获取方式、对象生命周期、单例模式、SET注入]]></title>
    <url>%2F2019%2F06%2F04%2FSpring%E7%AE%80%E4%BB%8B%E3%80%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%E3%80%81%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%81SET%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1. 框架框架是一套已经编写好的程序结构，开发者在使用框架之后，可以在此基础之上进行开发，而不必关心偏底层的问题。 框架通常可以提高开发效率，一定程度上还解决了一些其它的问题，可能是性能的问题，或者数据安全的问题，或者程度的可维护性的问题等等。 框架具体的表现就是一系列的jar包，并且，可能改变原有的编程方式或流程。 普通的jar包，例如dom4j、mysql-connector等，只是实现了某个功能，相当于是一套工具。 2. 课程任务 Spring框架 SpringMVC框架 MyBatis框架 3. Spring框架3.1. 作用创建和管理对象。 传统的创建对象的方法是：Object obj = new Object(); 使用Spring框架后：Object obj = 框架.getXXX(); 即：开发者无需关注对象的创建过程，改由框架来创建，当需要对象时，通过框架获取即可。 传统的管理对象可能有：student.setName(&quot;张三同学&quot;); 使用Spring框架后，无需执行相关代码，通过配置，获取对象时，相关属性就已经有值了。 3.2. 项目准备先创建Maven项目，勾选Create a simple project，Group Id为cn.tedu.spring，Artifact Id为SPRING-01，Packaging选择war，创建好项目后，默认项目是出错的，需要生成web.xml文件。 使用Spring之前，需要添加相关依赖，artifactId为spring-webmvc，且groupId是org.springframework，版本通常选择3.2或以上版本，但，目前尚不推荐使用5.x版本。 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;以上代码，应该添加到项目的pom.xml的&lt;dependencies&gt;节点的内部。 然后，下载得到applicationContext.xml文件，复制到项目中的src\main\resources文件夹下： 3.3. 通过Spring获取对象–类中存在无参数构造方法（常用）在Spring的配置文件（applicationContext.xml）中，添加： &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt; &lt;/bean&gt;以上配置中，class表示“类”，取值应该是类的全名，即包名和类名，id是自定义的名称，通常使用类名并且首字母改为小写，例如类名是Date，则id值为date，如果类名是Student，则id值为student。 完成配置后，就可以在程序中，通过Spring根据date名称获取java.util.Date的对象，可以在src\main\java中创建可执行的Java类： package cn.tedu.spring; public class SpringTest { public static void main(String[] args) { } }然后，编写程序： public static void main(String[] args) { // 加载Spring的配置文件，获取Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); // 通过Spring容器获取对象 Date date = (Date) ac.getBean(&quot;date&quot;); // 测试输出 System.out.println(date); } 自定义User类，在Spring的配置文件中添加配置，最终，在程序中，获取User类的对象。 以上操作，要求类中存在无参数的构造方法，如果不具备条件，则： Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;user&apos; defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.tedu.spring.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;() Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.tedu.spring.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;() Caused by: java.lang.NoSuchMethodException: cn.tedu.spring.User.&lt;init&gt;()这种做法对构造方法的访问权限并没有任何要求，即使是private权限，也不影响Spring创建对象！ 此次实现的代码中，关于ac变量，会提示警告：ac is never closed，即：推荐调用ac.close()以释放资源，但是，ApplicationContext接口中并没有声明close()方法，所以，应该将ac的类型声明为AbstractApplicationContext。 3.4. 通过Spring获取对象–类中存在静态工厂方法（不常用）工厂方法：调用后可以返回类的对象的方法，也可以理解为生产对象的方法。 以Calendar为例，它是一个抽象类，是不可以直接通过new 构造方法()此类语法创建对象的！但是，在这个类中，有static Calendar getInstance()方法，这个方法，就称之为Calendar类的静态工厂方法！ 在Spring的配置文件中，配置： &lt;bean id=&quot;calendar&quot; class=&quot;java.util.Calendar&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt;以上配置中，factory-method属性的值是静态工厂方法的名称。 配置时，无论是类的全名，还是方法的名称，都必须是已知条件。 练习：自定义类HuaWeiPhone，通过静态工厂方法，获取该类的对象！ 关于类： package cn.tedu.spring; public class HuaWeiPhone { // 使得当前类不存在无参数的构造方法 public HuaWeiPhone(Object obj){ super(); } // 静态工厂方法 public static HuaWeiPhone create() { return new HuaWeiPhone(null); } }关于配置： &lt;bean id=&quot;huaWeiPhone&quot; class=&quot;cn.tedu.spring.HuaWeiPhone&quot; factory-method=&quot;create&quot;&gt;&lt;/bean&gt;3.5. 通过Spring获取对象–存在实例工厂方法（不常用）实例工厂方法：通过某个实例（对象）调用的方法，并且，这个方法可以返回某个类的对象，是生产对象的方法。 假设存在某类需要被获取对象，不满足前序的2种条件： public class Car { public Car(Object obj) { } }则需要另一个类中存在工厂方法，可以创建它的对象 public class CarFactory { public Car makeCar() { return new Car(null); } }在配置时： &lt;bean id=&quot;carFactory&quot; class=&quot;cn.tedu.spring.CarFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;car&quot; class=&quot;cn.tedu.spring.Car&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;makeCar&quot;&gt; &lt;/bean&gt;以上配置中，factory-bean的值是工厂类的&lt;bean&gt;节点的id属性值。 3.6. 通过Spring获取对象–小结通过Spring创建对象，然后从Spring容器中获取对象，需要： 类中存在无参数的构造方法； 类中存在静态的工厂方法； 存在实例工厂方法。 以上3种方式中，第2种和第3种的使用频率较低，原因是满足条件的类较少。 3.7. 由Spring管理的对象的作用域单例：单一的实例，即在同一时刻，某个类的对象是唯一的！ 由Spring所管理的对象，默认都是单例的，在配置时，通过scope属性可以配置是否单例，默认取值为singleton，当取值为prototype时，是非单例的！ &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;单例模式可以区分为：懒汉式、饿汉式。 默认情况下，由Spring管理的单例对象是饿汉式的，通过lazy-init属性可以调整，该属性的值是布尔类型。 &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt;3.8. 由Spring管理的对象的生命周期仅由Spring管理的、单例的对象存在生命周期问题！ 开发者可以在任何自定义的、由Spring管理的类中添加初始化方法和销毁方法，方法必须是void和无参数的，例如： public class Stduent { // 初始化方法 public void init() { System.out.println(&quot;Student.init()&quot;); } // 销毁方法 public void destroy() { System.out.println(&quot;Student.destroy()&quot;); } }然后，在Spring的配置文件中进行配置： &lt;bean id=&quot;student&quot; class=&quot;cn.tedu.spring.Student&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;注意：对于非单例的对象而言，生命周期方法是没有意义的。 3.9. 通过SET方式注入属性的值基本概念：通过Spring的配置，确定某个类中的某个属性的值，使得最终获取对象时，属性是已经被赋值的。 假设存在UserDao类，在类中有String username和String password表示访问数据库的用户名和密码： public class UserDao { // 模拟：访问数据库的用户名 String username; // 模拟：访问数据库的密码 String password; }需要注入值的属性，必须有set方法，即设置它的值的方法，且方法名称必须以set作为前缀： public void setUsername(String u) { username = u; }然后，在Spring的配置文件中： &lt;bean id=&quot;userDao&quot; class=&quot;cn.tedu.spring.UserDao&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt; &lt;/property&gt; &lt;/bean&gt;即：添加子级&lt;property&gt;节点，在该节点，配置name和value，其中，name表示属性，value表示值。 注意：在配置的name时，值应该是需要注入的属性的set方法名称中不包含set的部分，且首字母是小写的！ 其它1. 关于Maven中依赖出错在添加依赖后，下载到的jar包文件可能是已损坏的，或数据不完整的，可能表现为：下载的jar包的数量不正确，或者，编写代码时，某个类无法识别等…… 解决方案： 打开Eclipse的设置，找到Maven &gt; User Settings，面板中的Local Repository就是本地仓库文件夹； 关闭Eclipse，因为已经打开的项目可能引用了本地仓库文件夹中的某个jar包，如果Eclipse正在运行，可能导致后续的删除操作无法执行； 打开本地仓库文件夹，删除出错的jar包文件（通常jar包文件对于新生来说不易于查找，所以，简单的操作方式就是将整个本地仓库文件夹全部删除）； 打开Eclipse，找到需要开发的项目，点击右键，选择Maven &gt; Update Project，在弹出的对话框中，选中Force update ...选项，然后，开始更新即可。 2. Resource leakResource leak表示“内存溢出”（内存泄露）。 模拟情景：假设存在D:/a.txt，在程序中，通过FileInputStream fis访问该文件，在访问过程中，如果出现异常，导致程序结束，然后，JVM中垃圾回收机制尝试回收垃圾时，找到了fis，但是，前序fis并没有正常关闭，仍然连接着硬盘上的a.txt文件，在JVM看来，这个fis仍处于使用状态，不是垃圾！但是，以程序员的角度来看，fis是一个变量，当程序崩溃时，这个变量就已经无法继续使用，就是个垃圾！所以，就会出现“已经无法继续使用的对象，却不会被视为垃圾数据，无法被回收！” 如果以上类似的垃圾数据越来越多，就会导致可用内存越来越少，当达到极端状态时，就会出现“内存溢出”！ 所以，其实，少量的内存溢出，并没有明显的危害！但是，作为开发者，应该尽量的避免任何可能出现的内存溢出！ 解决内存溢出的核心：尽早释放不再使用的资源，例如流、数据库访问的相关对象、XML的读写工具等连接型资源，对于可能抛出异常的代码，应该添加finally代码块，并在其中释放资源。 3. 单例模式示例public class King { private static King king; private King() { } public static King getKing() { if (king == null) { king = new King(); } return king; } }以上是懒汉式单例模式的代码，且，没有解释线程安全问题。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F03%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1.http协议 (了解)(1)什么是http协议?是一种网络应用层协议、规定了浏览器与web服务器之间如何通信以及相应的数据包的格式。 1)如何通信?step1.建立连接 step2.发送请求 step3.发送响应 step4.关闭连接 这样做的好处是，服务器可以利用有限的连接数为尽可能 多的请求服务。 2)数据包的格式a.请求数据包 请求行(请求方式 请求资源路径 协议和版本) 若干消息头 消息头是一些键值对，使用&quot;: &quot;隔开，通信的 双方可以借助于消息头来传递一些特定的信息，比如 浏览器可以发送&quot;user-agent&quot;消息头，告诉服务器 浏览器的类型和版本。 实体内容 如果请求类型为get，实体内容为空。 只有当请求类型为post时，实体内容才会有数据。b.响应数据包 状态行(协议类型和版本 状态码 状态描述) 注： 状态码是一个三位数字，表示服务器处理请求 的一种状态，常见状态码如下: 200: 正常 500: 系统出错 404: 请求路径出错 若干消息头 服务器也可以发送一些消息头给浏览器，比如，发送 content-type消息头，告诉浏览器，服务器返回的数据类型（包括编码）c.实体内容 程序的处理结果，浏览器会解析出来，生成相应的页面。(2)两种请求方式1)哪些情况下，浏览器会发送get请求?a.直接在浏览器地址栏输入地址。 b.点击链接。 c.表单的默认提交方式。2)get请求的特点a.会将请求参数显示在浏览器地址栏，不安全。 注： 因为有些网络设备(比如路由器)会记录访问地址。 b.会将请求参数添加到请求资源路径的后面，只能提交 少量的数据给服务器。 注： 因为请求行大约只能存放2k左右的数据。3)哪些情况下，浏览器会发送post请求a.设置表单的method属性值为&quot;post&quot;。 4)post请求的特点a.不会将请求参数显示在浏览器地址栏，相对安全。 注： http协议并不会对数据进行加密，所以，对于 敏感数据，需要进行加密处理(使用https协议)。 b.将请求参数添加到了实体内容里面，可以提交大量的 数据给服务器。2.Servlet输出中文需要注意的问题(1)为什么会产生乱码?因为out.println方法默认会使用”iso-8859-1”来编码。 (2)如何解决?response.setContentType(“text/html;charset=utf-8”); 3.读取请求参数值(1)String getParameter(String paramName)a.请求参数名(paramName)要与实际传递过来的请求 参数名一致，否则会获得null值。 b.提交表单时，如果不填写任何数据，会获得&quot;&quot;。(2)String[] getParamterValues(String paramName)a.当有多个请求参数名相同时，使用此方法。 b.对于多选框，如果不选择任何选项，会获得null值。4.表单包含有中文参数值，如何处理?(1)为什么会产生乱码?提交表单时，浏览器会对表单中的中文参数值进行编码，比如使用utf-8来编码，服务器端默认会使用iso-8859-1来解码，所以会产生乱码。 注： 浏览器会按照打开该表单所在页面时的字符集来编码。(2)如何解决?1)post请求request.setCharacterEncoding(“utf-8”); 注： 此行代码要添加到所有的getParameter方法的最前面。 只针对post请求有效。2)get请求修改tomcat的配置文件(server.xml) &lt;Connector URIEncoding=&quot;utf-8&quot;/&gt; 注： 只针对get请求有效。5.访问数据库step1.导包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;step2.添加jdbc.properties文件。 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/jsd1807db?useUnicode=true&amp;characterEncoding=UTF-8 username=root password=rootstep3.添加DBUtils类。 public class DBUtils { private static String driver; private static String url; private static String username; private static String password; private static BasicDataSource dataSource; static { Properties prop = new Properties(); InputStream ips = DBUtils.class .getClassLoader() .getResourceAsStream(&quot;jdbc.properties&quot;); try { prop.load(ips); driver = prop.getProperty(&quot;driver&quot;); url = prop.getProperty(&quot;url&quot;); username = prop.getProperty(&quot;username&quot;); password = prop.getProperty(&quot;password&quot;); //创建数据源对象 dataSource = new BasicDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(3); dataSource.setMaxActive(3); } catch (IOException e) { e.printStackTrace(); }finally { try { ips.close(); } catch (IOException e) { e.printStackTrace(); } } } public static Connection getConn() throws Exception { return dataSource.getConnection(); } public static void close(Connection conn, Statement stat, ResultSet rs) { try { if(rs!=null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if(stat!=null) { stat.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if(conn!=null) { //打开自动提交 conn.setAutoCommit(true); conn.close(); } } catch (SQLException e) { e.printStackTrace(); } } }step4.添加一张表(t_user) create table t_user( id int primary key auto_increment, username varchar(50) unique, password varchar(20), email varchar(30) );step5.在service方法里面，使用jdbc api访问数据库 public class AddUserServlet extends HttpServlet{ @Override protected void service( HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //处理表单中文参数值的问题 request.setCharacterEncoding(&quot;utf-8&quot;); /* * 这行代码的作用: * 1.设置content-type消息头的值。 * 2.out.println方法在输出时，会使用 * charset指定的字符集来编码。 */ response.setContentType( &quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); //读取用户信息 String username = request.getParameter(&quot;username&quot;); String pwd = request.getParameter(&quot;pwd&quot;); String email = request.getParameter(&quot;email&quot;); //将用户信息插入到数据库 Connection conn = null; PreparedStatement ps = null; try { conn = DBUtils.getConn(); String sql = &quot;INSERT INTO t_user &quot; + &quot;VALUES(null,?,?,?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, username); ps.setString(2, pwd); ps.setString(3, email); ps.executeUpdate(); out.println(&quot;添加成功&quot;); } catch (Exception e) { /* * step1.记日志(保留现场) * 注： * 在实际项目中，经常需要将异常 * 信息写到文件里面。 */ e.printStackTrace(); /* * step2.看异常能否恢复，如果 * 异常不能够恢复(比如数据库服务 * 停止、网络中断等等，这样的异常 * 我们一般称之为系统异常)，则提示 * 用户稍后重试； * 如果能够恢复，则立即恢复。 */ out.println(&quot;系统繁忙，稍后重试&quot;); }finally { DBUtils.close(conn, ps, null); } } }]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet简介、Servlet开发步骤、Servlet运行流程、常见问题及解决方式]]></title>
    <url>%2F2019%2F06%2F03%2FServlet%E7%AE%80%E4%BB%8B%E3%80%81Servlet%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E3%80%81Servlet%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.什么是Servlet?sun公司制订的一种用来扩展web服务器功能的组件规范。 (1)扩展web服务器功能web服务器只能够处理静态资源的请求（即需要事先将 静态页面写好），不能够处理动态资源的请求（即需要进行计算，生成动态页面），所以，需要扩展其功能。 可以使用Servlet来扩展web服务器功能，web服务器收到 请求之后，如果需要计算，则调用Servlet来处理。(2)组件规范1)什么是组件?符合规范、实现部分功能，并且需要部署到相应的容器当中才能运行的软件模块。 Servlet是一个组件，必须符合Servlet规范，并且需要部署到Servlet容器当中才能运行。2)什么是容器?符合规范、提供组件运行环境的程序。 Servlet容器(比如Tomcat)为Servlet提供运行环境 (主要是提供网络相关的服务)2.如何写一个Servlet?step1.写一个java类，实现Servlet接口或者继承HttpServlet。 step2.编译。 step3.打包。（即建立一个具有如下结构的文件夹） appname WEB-INF classes (放.class文件) lib (可选，放.jar文件) web.xml (部署描述文件)step4.部署。 把step3创建好的文件夹拷贝到容器指定的位置。 注： 可以将step3创建好的文件夹压缩成&quot;.war&quot;为后缀 的文件，然后拷贝。step5.启动容器，访问Servlet。 http://ip:port/appname/url-pattern 注: url-pattern在web.xml中设置。3.Servlet是如何运行的?比如，在浏览器地址栏输入http://localhost:8080/day01/hello step1.浏览器依据ip和port建立连接。 step2.浏览器将相关数据放到请求数据包，然后将请求 数据包发送给服务器。 step3.服务器解析请求数据包，将解析到的结果放到 request对象里面，同时，创建一个response对象。 step4.服务器依据请求路径，创建Servlet对象，然后 调用该对象的service方法。 注: 开发人员只需要调用request对象的方法，就 可以获得请求数据包中的数据。类似的，只需要调用 response对象的方法，就可以将处理结果写到 response对象里面，容器会从response对象中取 出处理结果，然后创建响应数据包并发送给浏览器。 step5.容器从response对象中取出处理结果，然后创建 响应数据包并发送给浏览器。 step6.浏览器解析响应数据包，生成结果页面。4.常见错误(1)404a.含义：服务器依据请求路径，找不到对应的资源。 b.错误原因: b1.请求路径写错。 b2.应用没有部署或者部署失败。(2)500a.含义:服务器端程序运行发生问题。 b.错误原因: b1.没有严格按照规范来写代码。 比如，没有继承HttpServlet或者实现Servlet 接口。又或者部署描述文件写错。 b2.代码写得不严谨。 比如，对请求参数值没有做任何检查就直接做类型 转换。(3)405a.含义:服务器找不到处理方法。 b.错误原因: 没有正确override HttpServlet的service方法。练习：写一个Servlet(比如DateServlet)，输出当前的系统日期，比如”2018-10-25” ## 提示 step1.创建一个maven工程。注意三个细节:细节1:选war包，如下图所示: 细节2:工程建完之后，默认没有带web.xml文件，需要添加web.xml文件,如下图所示: 细节3:指定servlet容器，如下图所示: step2.添加一个java类(DateServlet)参考代码如下: public class DateServlet extends HttpServlet{ public void service( HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException{ //生成日期信息 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateInfo = sdf.format(date); //输出日期 response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(dateInfo); out.close(); } }step3. 在web.xml添加该Servlet的配置参考配置如下: &lt;servlet&gt; &lt;servlet-name&gt;dateServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;web.DateServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dateServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/date&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;step4.部署、运行 Tomcat的配置请参考doc.tedu.cn上的文档。 练习写一个Servlet,计算一个人的BMI指数。 BMI指数 = 体重(公斤) / 身高(米) / 身高(米)]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主键约束、拆分表、事务、数据类型]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F%E3%80%81%E6%8B%86%E5%88%86%E8%A1%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主键约束 primary key主键：用于表示数据唯一性的字段称为主键约束： 是给表字段添加的限制条件主键约束：限制主键字段值不能重复并且非空 (唯一且非空)create table t1(id int primary key,name varchar(10)); insert into t1 values(1,&apos;Tom&apos;); insert into t1 values(1,&apos;Jerry&apos;);//失败 重复 insert into t1 values(null,&apos;ABC&apos;);//失败 不能为null 自增： auto_incrementcreate table t2(id int primary key auto_increment,name varchar(10)); insert into t2 values(null,&apos;AAA&apos;); insert into t2 values(2,&apos;AAA&apos;); insert into t2 values(10,&apos;mm&apos;); insert into t2 values(null,&apos;AAA&apos;); 1. 当字段值为null的时候值会自己增长 2. 自增字段值也可以手动赋值 3. 增长规则：从曾经出现的最大值基础上+1 4. 自增数值只增不减 (delete清空表 自增数值并不清零)注释 comment创建表声明字段的时候给字段添加的介绍create table t3(id int primary key auto_increment comment &apos;这是一个主键&apos;,name varchar(10) comment &apos;这是员工的姓名&apos;);` 和 ‘`: 用于修饰表名和字段名 可以省略create table `t4`(`id` int,`name` varchar(10));‘ :用于修饰字符串数据冗余如果表设计不够合理，保存大量数据的同时可能随之会出现大量重复数据，这些重复数据的现象就称为数据冗余，通过拆分表的形式解决冗余问题 练习：设计表保存以下数据：设计表保存以下数据： 保存男装分类(category)下西服分类下的商品皮尔卡丹西服，价格9800，库存98件 保存家用电器分类下，电视机分类下的小米电视，价格2500，库存108件 创建商品表 create table item(id int primary key auto_increment, name varchar(10),price int,num int,categoryid int); 创建分类表 create table category(id int primary key auto_increment,name varchar(10),parentid int); 插入数据 insert into category values(null,’男装’,null),(null,’西服’,1),(null,’家电’,null),(null,’电视机’,3); insert into item values(null,’皮尔卡丹’,9800,98,2),(null,’小米电视’,2500,108,4); 事务什么是事务？事务是数据库中执行SQL语句的最小工作单元，可以保证事务内的多条SQL语句要么全部成功，要么全部失败。 查看数据库自动提交的状态 show variables like ‘%autocommit%’; 关掉自动提交 0关闭 1开启 set autocommit=0; 测试转账： create table person(id int, name varchar(10),money int); insert into person values(1,’超人’,500),(2,’钢铁侠’,10000); 关掉自动提交： set autocommit=0; 先让超人+2000 update person set money=2500 where id=1; 开启另一个终端 验证 此时数据库文件中的数据并没改掉 让钢铁侠-2000 update person set money=8000 where id=2; 执行提交 commit; 回滚 rollback;将内存中的修改回滚到上次提交（commit）的点update person set money=100 where id=1; rollback;保存回滚点 savepointupdate person set money=100 where id=1; savepoint s1; update person set money=200 where id=1; savepoint s2; rollback to s1; SQL的分类DDL Data Definition Language 数据定义语言，包括 create,alter,drop,truncate ,不支持事务DML Data Manipulation Language 数据操作语言， 包括 insert,delete,update,select(DQL),支持事务DQL Data Query Language 数据查询语言，只包括select，和事务没有关系因为并没有修改数据TCL Transaction Control Language 事务控制语言，包括 commit,rollback, savepoint,rollback toDCL Data Control Language 数据控制语言，用于处理分配用户权限相关的操作 truncate truncate table 表名; 删除表并且创建一个新表 truncate、drop和delete的区别： delete用于删除数据，使用delete清空表时自增数值不清零 执行效率最低 drop 用于删除表 执行效率最高 truncate 用于删除表并创建新的空表，执行效率比delete要高，而且自增数值会清零 数据库的数据类型整数 常用整数有 int(m)和bigint(m)，m代表显示长度必须和zerofill结合使用 create table t_int(num int(10) zerofill); insert into t_int values(123); select * from t_int; 浮点数 常用浮点数double(m,d) m代表总长度 d代表小数长度 23.346 m=5 d=3 decimal超高精度浮点数，应用场景：涉及超高精度运算时使用 create table t_double(num double(5,3)); insert into t_double values(23.5678); 值为23.568 insert into t_double values(23.5); 值为23.500 字符串 char(m): 固定长度 m=10 abc 占10，效率高，最大255 varchar(m):可变长度 m=10 abc 占3，节省空间，最大65535，如果超过255建议使用text text(m):可变长度 最大65535日期 date:只能保存年月日 time:只能保存时分秒 datetime:保存年月日时分秒，默认值为null，最大值9999-12-31 timestamp(时间戳距离19700101 08：00：00):保存年月日时分秒，默认值为当前系统时间,最大值2038-01-19 create table t_time(t1 date,t2 time,t3 datetime,t4 timestamp); insert into t_time values(‘2018-10-16’,null,null,null); insert into t_time values (null,’20:06:32’,’2008-11-22 18:22:11’,null); 配置URL：jdbc:mysql://localhost:3306/db2?useUnicode=true&amp;characterEncoding=UTF-8 三方SQL工具：sqlyog]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库介绍 SQL基础]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D-SQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库之前通过流去操作文件保存数据的弊端： 执行效率低 开发成本高 一般只能保存小量数据 只能保存文本数据 什么是DB DataBase 数据库： 代表文件集合什么是DBMS DataBaseManagementSystem 数据库管理系统(软件) ，用于管理保存数据的文件集合，用于和程序员进行交互，常见的DBMS有：Oracle MySQL DB2 SQLServer Sqlite ，DBMS具备网络访问能力 SQL Structured Query Language：结构化查询语言，用户程序员和DBMS进行交互，用于程序员告诉DBMS到底对数据进行什么操作的 数据库的分类（了解） 关系型数据库：经过数学理论验证可以将现实生活中的各种关系保存到数据库，这种就称为关系型数据库。保存数据以表为单位 非关系数据库：一般都是为了解决某些特定场景的问题比如：缓存，高并发访问，Redis数据库（以key-value形式保存数据）常见的关系型数据 MySQL: 属于Oracle公司的产品，08被Sun公司收购，09年Sun公司被Oracle收购，开源免费，被收购后发布5.5版本使用Oracle的部分技术，性能提高了30%以上，用户量增多，计划把MySQL闭源 原MySQL程序员离开Oracle创建了MariaDB 老板女儿Maria。市场排名第一 Oracle: 排名第二，闭源 性能最高 收费最贵 DB2： IBM公司产品 闭源项目 SQLServer：微软公司产品 闭源 Sqlite：轻量级数据库，安装包几十k，应用在嵌入式设备或移动设备上， 开源和闭源 开源：开放源代码 免费试用，通过卖服务盈利，社会上会有一些大牛程序员会无偿的维护和升级 闭源：不开放源代码 收费，通过卖产品+服务盈利 ，有大牛会攻击破坏，但是人家养了一群人维护升级 打开客户端连接MySQL 在终端中执行： mysql -uroot -p 回车 如果有密码写密码 回车 如果没有密码则直接回车 和数据库相关的SQL查询所有数据库 show databases;创建数据库 create database db1;查看数据库详情 show create database db1;创建数据库指定字符集 create database db2 character set gbk/utf8;删除数据库 drop database db2;使用数据库 use db1;和表相关的SQL查询所有表 show tables;创建表 create table 表名(字段1名 字段1的类型,字段2名 字段2的类型,…..); create table person(name varchar(10),age int); 创建一个学生表（student） 保存学号id,姓名name,年龄age,语文chinese,数学math,英语english create table student(id int,name varchar(10),age int,chinese int,math int,english int);查看表详情 show create table 表名; show create table person;创建表时指定表的引擎和字符集 create table t1(name varchar(10)) engine=myisam charset=gbk; 表的引擎 innodb：支持数据库的高级操作如：外键、事务等，默认引擎 myisam：只支持基础的增删改查操作 SQL格式： 可以有换行 最后以;结尾 关键字之间需要有空格(可以写多个空格，建议写一个) 查看表字段 desc 表名;删除表 drop table 表名;修改表相关修改表名——rename table 原名 to 新名; rename table student to stu;修改表的引擎和字符集——alter table 表名 engine=myisam/innodb charset=utf8/gbk; alter table stu engine=myisam charset=gbk;添加表字段最后面： alter table 表名 add 字段名 字段类型;最前面： alter table 表名 add 字段名 字段类型 first;xxx的后面: alter table 表名 add 字段名 字段类型 after xxx; create table hero(name varchar(10)); alter table hero add age int; alter table hero add id int first; alter table hero add sal int after name;删除表字段——alter table 表名 drop 字段名; alter table hero drop sal;修改表字段的名字和类型——alter table 表名 change 原字段名 新字段名 新字段类型; alter table hero change name heroname varchar(5);修改表字段的类型和位置——alter table 表名 modify 字段名 类型 位置; alter table hero modify age int first(after xxx); 练习： 创建数据库newdb并使用， 里面创建员工表t_emp只有name字段 引擎为myisam 字符集为gbk 1). create database newdb; 2). use newdb; 3). create table t_emp(name varchar(10)) engine=myisam charset=gbk; 修改表名为emp 1). rename table t_emp to emp; 修改引擎为innodb 字符集为utf8 1). alter table emp engine=innodb charset=utf8; 添加部门编号字段deptno 在最后面 1). alter table emp add deptno int; 添加员工编号 empno在最前面 1). alter table emp add empno int first; 添加salary字段在name的后面 1). alter table emp add salary int after name; 修改salary字段名字为sal，把sal放在empno的后面 1). alter table emp change salary sal int; 2). alter table emp modify sal int after empno; 删除sal字段 1).alter table emp drop sal; 删除表 1).drop table emp; 删除数据库1).drop database newdb; 数据相关插入数据create table emp(id int,name varchar(10),age int,sal int); 全表插入数据： insert into emp values(1,’Tom’,18,3000); 指定字段插入数据： insert into emp (name,age) values(‘Jerry’,19); insert into emp (name) values(‘李白’); 批量插入数据： insert into emp values(3,’刘备’,28,6000),(4,’张飞’,20,5000),(5,’关羽’,25,9000); insert into emp (name,age) values(‘悟空’,500),(‘八戒’,400),(‘沙僧’,200);查询数据 查询全部数据的全部字段信息 select * from emp; 查询所有员工的姓名和年龄 select name,age from emp; 查询年龄在25岁以下的员工信息 select * from emp where age&lt;25; 查询工资3000块钱的员工姓名、年龄、工资 select name,age,sal from emp where sal=3000;修改数据 修改Tom的工资为3333 update emp set sal=3333 where name=’Tom’; 修改30岁以下的工资为666 update emp set sal=666 where age&lt;30; 修改id等于3的名字为吕布 年龄为55 工资为20000 update emp set name=’吕布’, age=55, sal=20000 where id=3; 修改工资为null的工资为800 update emp set sal=800 where sal is null;删除数据 删除id=1的员工 delete from emp where id=1; 删除年龄在25岁以下的员工 delete from emp where age&lt;25; 删除全部数据 delete from emp; insert into t1 (字段名1,字段名2) values(值1,值2),(值1,值2);select name,age from t1 where id&lt;5;update t1 set 字段名=值, 字段名=值 where id=5;delete from t1 where id&lt;3; 练习： 创建hero表如果存在则先删除再创建， id 姓名name 类型type 金币money 插入以下数据 1 诸葛亮 法师 18888 ， 2 孙悟空 打野 18888 ，3 小乔 法师 6888，4 黄忠 射手 8888， 5 刘备 战士 6888 修改所有18888的为28888 修改所有打野为刺客 删除价格为6888的英雄 修改孙悟空为猪八戒 删除id为1，2，3的英雄 修改所有英雄的类型为已阵亡 删除所有数据 删除表 中文字符问题 set names gbk;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
